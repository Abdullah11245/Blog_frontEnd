/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parse-srcset";
exports.ids = ["vendor-chunks/parse-srcset"];
exports.modules = {

/***/ "(ssr)/./node_modules/parse-srcset/src/parse-srcset.js":
/*!*******************************************************!*\
  !*** ./node_modules/parse-srcset/src/parse-srcset.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Srcset Parser\n *\n * By Alex Bell |  MIT License\n *\n * JS Parser for the string value that appears in markup <img srcset=\"here\">\n *\n * @returns Array [{url: _, d: _, w: _, h:_}, ...]\n *\n * Based super duper closely on the reference algorithm at:\n * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n *\n * Most comments are copied in directly from the spec\n * (except for comments in parens).\n */ (function(root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(this, function() {\n    // 1. Let input be the value passed to this algorithm.\n    return function(input) {\n        // UTILITY FUNCTIONS\n        // Manual is faster than RegEx\n        // http://bjorn.tipling.com/state-and-regular-expressions-in-javascript\n        // http://jsperf.com/whitespace-character/5\n        function isSpace(c) {\n            return c === \" \" || // space\n            c === \"\t\" || // horizontal tab\n            c === \"\\n\" || // new line\n            c === \"\\f\" || // form feed\n            c === \"\\r\"; // carriage return\n        }\n        function collectCharacters(regEx) {\n            var chars, match = regEx.exec(input.substring(pos));\n            if (match) {\n                chars = match[0];\n                pos += chars.length;\n                return chars;\n            }\n        }\n        var inputLength = input.length, // (Don't use \\s, to avoid matching non-breaking space)\n        regexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/, regexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/, regexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\\d+$/, // ( Positive or negative or unsigned integers or decimals, without or without exponents.\n        // Must include at least one digit.\n        // According to spec tests any decimal point must be followed by a digit.\n        // No leading plus sign is allowed.)\n        // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number\n        regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, // 2. Let position be a pointer into input, initially pointing at the start\n        //    of the string.\n        pos = 0, // 3. Let candidates be an initially empty source set.\n        candidates = [];\n        // 4. Splitting loop: Collect a sequence of characters that are space\n        //    characters or U+002C COMMA characters. If any U+002C COMMA characters\n        //    were collected, that is a parse error.\n        while(true){\n            collectCharacters(regexLeadingCommasOrSpaces);\n            // 5. If position is past the end of input, return candidates and abort these steps.\n            if (pos >= inputLength) {\n                return candidates; // (we're done, this is the sole return path)\n            }\n            // 6. Collect a sequence of characters that are not space characters,\n            //    and let that be url.\n            url = collectCharacters(regexLeadingNotSpaces);\n            // 7. Let descriptors be a new empty list.\n            descriptors = [];\n            // 8. If url ends with a U+002C COMMA character (,), follow these substeps:\n            //\t\t(1). Remove all trailing U+002C COMMA characters from url. If this removed\n            //         more than one character, that is a parse error.\n            if (url.slice(-1) === \",\") {\n                url = url.replace(regexTrailingCommas, \"\");\n                // (Jump ahead to step 9 to skip tokenization and just push the candidate).\n                parseDescriptors();\n            //\tOtherwise, follow these substeps:\n            } else {\n                tokenize();\n            } // (close else of step 8)\n        // 16. Return to the step labeled splitting loop.\n        } // (Close of big while loop.)\n        /**\n\t\t * Tokenizes descriptor properties prior to parsing\n\t\t * Returns undefined.\n\t\t */ function tokenize() {\n            // 8.1. Descriptor tokeniser: Skip whitespace\n            collectCharacters(regexLeadingSpaces);\n            // 8.2. Let current descriptor be the empty string.\n            currentDescriptor = \"\";\n            // 8.3. Let state be in descriptor.\n            state = \"in descriptor\";\n            while(true){\n                // 8.4. Let c be the character at position.\n                c = input.charAt(pos);\n                //  Do the following depending on the value of state.\n                //  For the purpose of this step, \"EOF\" is a special character representing\n                //  that position is past the end of input.\n                // In descriptor\n                if (state === \"in descriptor\") {\n                    // Do the following, depending on the value of c:\n                    // Space character\n                    // If current descriptor is not empty, append current descriptor to\n                    // descriptors and let current descriptor be the empty string.\n                    // Set state to after descriptor.\n                    if (isSpace(c)) {\n                        if (currentDescriptor) {\n                            descriptors.push(currentDescriptor);\n                            currentDescriptor = \"\";\n                            state = \"after descriptor\";\n                        }\n                    // U+002C COMMA (,)\n                    // Advance position to the next character in input. If current descriptor\n                    // is not empty, append current descriptor to descriptors. Jump to the step\n                    // labeled descriptor parser.\n                    } else if (c === \",\") {\n                        pos += 1;\n                        if (currentDescriptor) {\n                            descriptors.push(currentDescriptor);\n                        }\n                        parseDescriptors();\n                        return;\n                    // U+0028 LEFT PARENTHESIS (()\n                    // Append c to current descriptor. Set state to in parens.\n                    } else if (c === \"(\") {\n                        currentDescriptor = currentDescriptor + c;\n                        state = \"in parens\";\n                    // EOF\n                    // If current descriptor is not empty, append current descriptor to\n                    // descriptors. Jump to the step labeled descriptor parser.\n                    } else if (c === \"\") {\n                        if (currentDescriptor) {\n                            descriptors.push(currentDescriptor);\n                        }\n                        parseDescriptors();\n                        return;\n                    // Anything else\n                    // Append c to current descriptor.\n                    } else {\n                        currentDescriptor = currentDescriptor + c;\n                    }\n                // (end \"in descriptor\"\n                // In parens\n                } else if (state === \"in parens\") {\n                    // U+0029 RIGHT PARENTHESIS ())\n                    // Append c to current descriptor. Set state to in descriptor.\n                    if (c === \")\") {\n                        currentDescriptor = currentDescriptor + c;\n                        state = \"in descriptor\";\n                    // EOF\n                    // Append current descriptor to descriptors. Jump to the step labeled\n                    // descriptor parser.\n                    } else if (c === \"\") {\n                        descriptors.push(currentDescriptor);\n                        parseDescriptors();\n                        return;\n                    // Anything else\n                    // Append c to current descriptor.\n                    } else {\n                        currentDescriptor = currentDescriptor + c;\n                    }\n                // After descriptor\n                } else if (state === \"after descriptor\") {\n                    // Do the following, depending on the value of c:\n                    // Space character: Stay in this state.\n                    if (isSpace(c)) {\n                    // EOF: Jump to the step labeled descriptor parser.\n                    } else if (c === \"\") {\n                        parseDescriptors();\n                        return;\n                    // Anything else\n                    // Set state to in descriptor. Set position to the previous character in input.\n                    } else {\n                        state = \"in descriptor\";\n                        pos -= 1;\n                    }\n                }\n                // Advance position to the next character in input.\n                pos += 1;\n            // Repeat this step.\n            } // (close while true loop)\n        }\n        /**\n\t\t * Adds descriptor properties to a candidate, pushes to the candidates array\n\t\t * @return undefined\n\t\t */ // Declared outside of the while loop so that it's only created once.\n        function parseDescriptors() {\n            // 9. Descriptor parser: Let error be no.\n            var pError = false, // 10. Let width be absent.\n            // 11. Let density be absent.\n            // 12. Let future-compat-h be absent. (We're implementing it now as h)\n            w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;\n            // 13. For each descriptor in descriptors, run the appropriate set of steps\n            // from the following list:\n            for(i = 0; i < descriptors.length; i++){\n                desc = descriptors[i];\n                lastChar = desc[desc.length - 1];\n                value = desc.substring(0, desc.length - 1);\n                intVal = parseInt(value, 10);\n                floatVal = parseFloat(value);\n                // If the descriptor consists of a valid non-negative integer followed by\n                // a U+0077 LATIN SMALL LETTER W character\n                if (regexNonNegativeInteger.test(value) && lastChar === \"w\") {\n                    // If width and density are not both absent, then let error be yes.\n                    if (w || d) {\n                        pError = true;\n                    }\n                    // Apply the rules for parsing non-negative integers to the descriptor.\n                    // If the result is zero, let error be yes.\n                    // Otherwise, let width be the result.\n                    if (intVal === 0) {\n                        pError = true;\n                    } else {\n                        w = intVal;\n                    }\n                // If the descriptor consists of a valid floating-point number followed by\n                // a U+0078 LATIN SMALL LETTER X character\n                } else if (regexFloatingPoint.test(value) && lastChar === \"x\") {\n                    // If width, density and future-compat-h are not all absent, then let error\n                    // be yes.\n                    if (w || d || h) {\n                        pError = true;\n                    }\n                    // Apply the rules for parsing floating-point number values to the descriptor.\n                    // If the result is less than zero, let error be yes. Otherwise, let density\n                    // be the result.\n                    if (floatVal < 0) {\n                        pError = true;\n                    } else {\n                        d = floatVal;\n                    }\n                // If the descriptor consists of a valid non-negative integer followed by\n                // a U+0068 LATIN SMALL LETTER H character\n                } else if (regexNonNegativeInteger.test(value) && lastChar === \"h\") {\n                    // If height and density are not both absent, then let error be yes.\n                    if (h || d) {\n                        pError = true;\n                    }\n                    // Apply the rules for parsing non-negative integers to the descriptor.\n                    // If the result is zero, let error be yes. Otherwise, let future-compat-h\n                    // be the result.\n                    if (intVal === 0) {\n                        pError = true;\n                    } else {\n                        h = intVal;\n                    }\n                // Anything else, Let error be yes.\n                } else {\n                    pError = true;\n                }\n            } // (close step 13 for loop)\n            // 15. If error is still no, then append a new image source to candidates whose\n            // URL is url, associated with a width width if not absent and a pixel\n            // density density if not absent. Otherwise, there is a parse error.\n            if (!pError) {\n                candidate.url = url;\n                if (w) {\n                    candidate.w = w;\n                }\n                if (d) {\n                    candidate.d = d;\n                }\n                if (h) {\n                    candidate.h = h;\n                }\n                candidates.push(candidate);\n            } else if (console && console.log) {\n                console.log(\"Invalid srcset descriptor found in '\" + input + \"' at '\" + desc + \"'.\");\n            }\n        } // (close parseDescriptors fn)\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGFyc2Utc3Jjc2V0L3NyYy9wYXJzZS1zcmNzZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FFQSxVQUFVQSxJQUFJLEVBQUVDLE9BQU87SUFDdkIsSUFBSSxJQUEwQyxFQUFFO1FBQy9DLHdDQUF3QztRQUN4Q0MsaUNBQU8sRUFBRSxvQ0FBRUQsT0FBT0E7QUFBQTtBQUFBO0FBQUEsa0dBQUNBO0lBQ3BCLE9BQU8sRUFRTjtBQUNGLEdBQUUsSUFBSSxFQUFFO0lBRVAsc0RBQXNEO0lBQ3RELE9BQU8sU0FBVU0sS0FBSztRQUVyQixvQkFBb0I7UUFFcEIsOEJBQThCO1FBQzlCLHVFQUF1RTtRQUN2RSwyQ0FBMkM7UUFDM0MsU0FBU0MsUUFBUUMsQ0FBQztZQUNqQixPQUFRQSxNQUFNLE9BQVksUUFBUTtZQUNsQ0EsTUFBTSxPQUFZLGlCQUFpQjtZQUNuQ0EsTUFBTSxRQUFZLFdBQVc7WUFDN0JBLE1BQU0sUUFBWSxZQUFZO1lBQzlCQSxNQUFNLE1BQVksa0JBQWtCO1FBQ3JDO1FBRUEsU0FBU0Msa0JBQWtCQyxLQUFLO1lBQy9CLElBQUlDLE9BQ0hDLFFBQVFGLE1BQU1HLElBQUksQ0FBQ1AsTUFBTVEsU0FBUyxDQUFDQztZQUNwQyxJQUFJSCxPQUFPO2dCQUNWRCxRQUFRQyxLQUFLLENBQUUsRUFBRztnQkFDbEJHLE9BQU9KLE1BQU1LLE1BQU07Z0JBQ25CLE9BQU9MO1lBQ1I7UUFDRDtRQUVBLElBQUlNLGNBQWNYLE1BQU1VLE1BQU0sRUFFN0IsdURBQXVEO1FBQ3ZERSxxQkFBcUIscUJBQ3JCQyw2QkFBNkIsc0JBQzdCQyx3QkFBd0Isc0JBQ3hCQyxzQkFBc0IsU0FDdEJDLDBCQUEwQixTQUUxQix5RkFBeUY7UUFDekYsbUNBQW1DO1FBQ25DLHlFQUF5RTtRQUN6RSxvQ0FBb0M7UUFDcEMseUZBQXlGO1FBQ3pGQyxxQkFBcUIscURBRXJCQyxLQUNBQyxhQUNBQyxtQkFDQUMsT0FDQW5CLEdB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SUFFakM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Jsb2cvLi9ub2RlX21vZHVsZXMvcGFyc2Utc3Jjc2V0L3NyYy9wYXJzZS1zcmNzZXQuanM/ZWY4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNyY3NldCBQYXJzZXJcbiAqXG4gKiBCeSBBbGV4IEJlbGwgfCAgTUlUIExpY2Vuc2VcbiAqXG4gKiBKUyBQYXJzZXIgZm9yIHRoZSBzdHJpbmcgdmFsdWUgdGhhdCBhcHBlYXJzIGluIG1hcmt1cCA8aW1nIHNyY3NldD1cImhlcmVcIj5cbiAqXG4gKiBAcmV0dXJucyBBcnJheSBbe3VybDogXywgZDogXywgdzogXywgaDpffSwgLi4uXVxuICpcbiAqIEJhc2VkIHN1cGVyIGR1cGVyIGNsb3NlbHkgb24gdGhlIHJlZmVyZW5jZSBhbGdvcml0aG0gYXQ6XG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjcGFyc2UtYS1zcmNzZXQtYXR0cmlidXRlXG4gKlxuICogTW9zdCBjb21tZW50cyBhcmUgY29waWVkIGluIGRpcmVjdGx5IGZyb20gdGhlIHNwZWNcbiAqIChleGNlcHQgZm9yIGNvbW1lbnRzIGluIHBhcmVucykuXG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuXHRcdC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuXHRcdC8vIGxpa2UgTm9kZS5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHQvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuXHRcdHJvb3QucGFyc2VTcmNzZXQgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8vIDEuIExldCBpbnB1dCBiZSB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoaXMgYWxnb3JpdGhtLlxuXHRyZXR1cm4gZnVuY3Rpb24gKGlucHV0KSB7XG5cblx0XHQvLyBVVElMSVRZIEZVTkNUSU9OU1xuXG5cdFx0Ly8gTWFudWFsIGlzIGZhc3RlciB0aGFuIFJlZ0V4XG5cdFx0Ly8gaHR0cDovL2Jqb3JuLnRpcGxpbmcuY29tL3N0YXRlLWFuZC1yZWd1bGFyLWV4cHJlc3Npb25zLWluLWphdmFzY3JpcHRcblx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS93aGl0ZXNwYWNlLWNoYXJhY3Rlci81XG5cdFx0ZnVuY3Rpb24gaXNTcGFjZShjKSB7XG5cdFx0XHRyZXR1cm4gKGMgPT09IFwiXFx1MDAyMFwiIHx8IC8vIHNwYWNlXG5cdFx0XHRjID09PSBcIlxcdTAwMDlcIiB8fCAvLyBob3Jpem9udGFsIHRhYlxuXHRcdFx0YyA9PT0gXCJcXHUwMDBBXCIgfHwgLy8gbmV3IGxpbmVcblx0XHRcdGMgPT09IFwiXFx1MDAwQ1wiIHx8IC8vIGZvcm0gZmVlZFxuXHRcdFx0YyA9PT0gXCJcXHUwMDBEXCIpOyAgLy8gY2FycmlhZ2UgcmV0dXJuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29sbGVjdENoYXJhY3RlcnMocmVnRXgpIHtcblx0XHRcdHZhciBjaGFycyxcblx0XHRcdFx0bWF0Y2ggPSByZWdFeC5leGVjKGlucHV0LnN1YnN0cmluZyhwb3MpKTtcblx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRjaGFycyA9IG1hdGNoWyAwIF07XG5cdFx0XHRcdHBvcyArPSBjaGFycy5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiBjaGFycztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cblx0XHRcdC8vIChEb24ndCB1c2UgXFxzLCB0byBhdm9pZCBtYXRjaGluZyBub24tYnJlYWtpbmcgc3BhY2UpXG5cdFx0XHRyZWdleExlYWRpbmdTcGFjZXMgPSAvXlsgXFx0XFxuXFxyXFx1MDAwY10rLyxcblx0XHRcdHJlZ2V4TGVhZGluZ0NvbW1hc09yU3BhY2VzID0gL15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvLFxuXHRcdFx0cmVnZXhMZWFkaW5nTm90U3BhY2VzID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvLFxuXHRcdFx0cmVnZXhUcmFpbGluZ0NvbW1hcyA9IC9bLF0rJC8sXG5cdFx0XHRyZWdleE5vbk5lZ2F0aXZlSW50ZWdlciA9IC9eXFxkKyQvLFxuXG5cdFx0XHQvLyAoIFBvc2l0aXZlIG9yIG5lZ2F0aXZlIG9yIHVuc2lnbmVkIGludGVnZXJzIG9yIGRlY2ltYWxzLCB3aXRob3V0IG9yIHdpdGhvdXQgZXhwb25lbnRzLlxuXHRcdFx0Ly8gTXVzdCBpbmNsdWRlIGF0IGxlYXN0IG9uZSBkaWdpdC5cblx0XHRcdC8vIEFjY29yZGluZyB0byBzcGVjIHRlc3RzIGFueSBkZWNpbWFsIHBvaW50IG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkaWdpdC5cblx0XHRcdC8vIE5vIGxlYWRpbmcgcGx1cyBzaWduIGlzIGFsbG93ZWQuKVxuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN2YWxpZC1mbG9hdGluZy1wb2ludC1udW1iZXJcblx0XHRcdHJlZ2V4RmxvYXRpbmdQb2ludCA9IC9eLT8oPzpbMC05XSt8WzAtOV0qXFwuWzAtOV0rKSg/OltlRV1bKy1dP1swLTldKyk/JC8sXG5cblx0XHRcdHVybCxcblx0XHRcdGRlc2NyaXB0b3JzLFxuXHRcdFx0Y3VycmVudERlc2NyaXB0b3IsXG5cdFx0XHRzdGF0ZSxcblx0XHRcdGMsXG5cblx0XHRcdC8vIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvaW50ZXIgaW50byBpbnB1dCwgaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydFxuXHRcdFx0Ly8gICAgb2YgdGhlIHN0cmluZy5cblx0XHRcdHBvcyA9IDAsXG5cblx0XHRcdC8vIDMuIExldCBjYW5kaWRhdGVzIGJlIGFuIGluaXRpYWxseSBlbXB0eSBzb3VyY2Ugc2V0LlxuXHRcdFx0Y2FuZGlkYXRlcyA9IFtdO1xuXG5cdFx0Ly8gNC4gU3BsaXR0aW5nIGxvb3A6IENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHRoYXQgYXJlIHNwYWNlXG5cdFx0Ly8gICAgY2hhcmFjdGVycyBvciBVKzAwMkMgQ09NTUEgY2hhcmFjdGVycy4gSWYgYW55IFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzXG5cdFx0Ly8gICAgd2VyZSBjb2xsZWN0ZWQsIHRoYXQgaXMgYSBwYXJzZSBlcnJvci5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Y29sbGVjdENoYXJhY3RlcnMocmVnZXhMZWFkaW5nQ29tbWFzT3JTcGFjZXMpO1xuXG5cdFx0XHQvLyA1LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHJldHVybiBjYW5kaWRhdGVzIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cblx0XHRcdGlmIChwb3MgPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGNhbmRpZGF0ZXM7IC8vICh3ZSdyZSBkb25lLCB0aGlzIGlzIHRoZSBzb2xlIHJldHVybiBwYXRoKVxuXHRcdFx0fVxuXG5cdFx0XHQvLyA2LiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBub3Qgc3BhY2UgY2hhcmFjdGVycyxcblx0XHRcdC8vICAgIGFuZCBsZXQgdGhhdCBiZSB1cmwuXG5cdFx0XHR1cmwgPSBjb2xsZWN0Q2hhcmFjdGVycyhyZWdleExlYWRpbmdOb3RTcGFjZXMpO1xuXG5cdFx0XHQvLyA3LiBMZXQgZGVzY3JpcHRvcnMgYmUgYSBuZXcgZW1wdHkgbGlzdC5cblx0XHRcdGRlc2NyaXB0b3JzID0gW107XG5cblx0XHRcdC8vIDguIElmIHVybCBlbmRzIHdpdGggYSBVKzAwMkMgQ09NTUEgY2hhcmFjdGVyICgsKSwgZm9sbG93IHRoZXNlIHN1YnN0ZXBzOlxuXHRcdFx0Ly9cdFx0KDEpLiBSZW1vdmUgYWxsIHRyYWlsaW5nIFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzIGZyb20gdXJsLiBJZiB0aGlzIHJlbW92ZWRcblx0XHRcdC8vICAgICAgICAgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXIsIHRoYXQgaXMgYSBwYXJzZSBlcnJvci5cblx0XHRcdGlmICh1cmwuc2xpY2UoLTEpID09PSBcIixcIikge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZShyZWdleFRyYWlsaW5nQ29tbWFzLCBcIlwiKTtcblx0XHRcdFx0Ly8gKEp1bXAgYWhlYWQgdG8gc3RlcCA5IHRvIHNraXAgdG9rZW5pemF0aW9uIGFuZCBqdXN0IHB1c2ggdGhlIGNhbmRpZGF0ZSkuXG5cdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblxuXHRcdFx0XHQvL1x0T3RoZXJ3aXNlLCBmb2xsb3cgdGhlc2Ugc3Vic3RlcHM6XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b2tlbml6ZSgpO1xuXHRcdFx0fSAvLyAoY2xvc2UgZWxzZSBvZiBzdGVwIDgpXG5cblx0XHRcdC8vIDE2LiBSZXR1cm4gdG8gdGhlIHN0ZXAgbGFiZWxlZCBzcGxpdHRpbmcgbG9vcC5cblx0XHR9IC8vIChDbG9zZSBvZiBiaWcgd2hpbGUgbG9vcC4pXG5cblx0XHQvKipcblx0XHQgKiBUb2tlbml6ZXMgZGVzY3JpcHRvciBwcm9wZXJ0aWVzIHByaW9yIHRvIHBhcnNpbmdcblx0XHQgKiBSZXR1cm5zIHVuZGVmaW5lZC5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0b2tlbml6ZSgpIHtcblxuXHRcdFx0Ly8gOC4xLiBEZXNjcmlwdG9yIHRva2VuaXNlcjogU2tpcCB3aGl0ZXNwYWNlXG5cdFx0XHRjb2xsZWN0Q2hhcmFjdGVycyhyZWdleExlYWRpbmdTcGFjZXMpO1xuXG5cdFx0XHQvLyA4LjIuIExldCBjdXJyZW50IGRlc2NyaXB0b3IgYmUgdGhlIGVtcHR5IHN0cmluZy5cblx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gXCJcIjtcblxuXHRcdFx0Ly8gOC4zLiBMZXQgc3RhdGUgYmUgaW4gZGVzY3JpcHRvci5cblx0XHRcdHN0YXRlID0gXCJpbiBkZXNjcmlwdG9yXCI7XG5cblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cblx0XHRcdFx0Ly8gOC40LiBMZXQgYyBiZSB0aGUgY2hhcmFjdGVyIGF0IHBvc2l0aW9uLlxuXHRcdFx0XHRjID0gaW5wdXQuY2hhckF0KHBvcyk7XG5cblx0XHRcdFx0Ly8gIERvIHRoZSBmb2xsb3dpbmcgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBzdGF0ZS5cblx0XHRcdFx0Ly8gIEZvciB0aGUgcHVycG9zZSBvZiB0aGlzIHN0ZXAsIFwiRU9GXCIgaXMgYSBzcGVjaWFsIGNoYXJhY3RlciByZXByZXNlbnRpbmdcblx0XHRcdFx0Ly8gIHRoYXQgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LlxuXG5cdFx0XHRcdC8vIEluIGRlc2NyaXB0b3Jcblx0XHRcdFx0aWYgKHN0YXRlID09PSBcImluIGRlc2NyaXB0b3JcIikge1xuXHRcdFx0XHRcdC8vIERvIHRoZSBmb2xsb3dpbmcsIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgYzpcblxuXHRcdFx0XHRcdC8vIFNwYWNlIGNoYXJhY3RlclxuXHRcdFx0XHRcdC8vIElmIGN1cnJlbnQgZGVzY3JpcHRvciBpcyBub3QgZW1wdHksIGFwcGVuZCBjdXJyZW50IGRlc2NyaXB0b3IgdG9cblx0XHRcdFx0XHQvLyBkZXNjcmlwdG9ycyBhbmQgbGV0IGN1cnJlbnQgZGVzY3JpcHRvciBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuXHRcdFx0XHRcdC8vIFNldCBzdGF0ZSB0byBhZnRlciBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdGlmIChpc1NwYWNlKGMpKSB7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudERlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBcImFmdGVyIGRlc2NyaXB0b3JcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVSswMDJDIENPTU1BICgsKVxuXHRcdFx0XHRcdFx0Ly8gQWR2YW5jZSBwb3NpdGlvbiB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgaW4gaW5wdXQuIElmIGN1cnJlbnQgZGVzY3JpcHRvclxuXHRcdFx0XHRcdFx0Ly8gaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvIGRlc2NyaXB0b3JzLiBKdW1wIHRvIHRoZSBzdGVwXG5cdFx0XHRcdFx0XHQvLyBsYWJlbGVkIGRlc2NyaXB0b3IgcGFyc2VyLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gXCIsXCIpIHtcblx0XHRcdFx0XHRcdHBvcyArPSAxO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnREZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHQvLyBVKzAwMjggTEVGVCBQQVJFTlRIRVNJUyAoKClcblx0XHRcdFx0XHRcdC8vIEFwcGVuZCBjIHRvIGN1cnJlbnQgZGVzY3JpcHRvci4gU2V0IHN0YXRlIHRvIGluIHBhcmVucy5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXFx1MDAyOFwiKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcblx0XHRcdFx0XHRcdHN0YXRlID0gXCJpbiBwYXJlbnNcIjtcblxuXHRcdFx0XHRcdFx0Ly8gRU9GXG5cdFx0XHRcdFx0XHQvLyBJZiBjdXJyZW50IGRlc2NyaXB0b3IgaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvXG5cdFx0XHRcdFx0XHQvLyBkZXNjcmlwdG9ycy4gSnVtcCB0byB0aGUgc3RlcCBsYWJlbGVkIGRlc2NyaXB0b3IgcGFyc2VyLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnREZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlXG5cdFx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyAoZW5kIFwiaW4gZGVzY3JpcHRvclwiXG5cblx0XHRcdFx0XHQvLyBJbiBwYXJlbnNcblx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJpbiBwYXJlbnNcIikge1xuXG5cdFx0XHRcdFx0Ly8gVSswMDI5IFJJR0hUIFBBUkVOVEhFU0lTICgpKVxuXHRcdFx0XHRcdC8vIEFwcGVuZCBjIHRvIGN1cnJlbnQgZGVzY3JpcHRvci4gU2V0IHN0YXRlIHRvIGluIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0aWYgKGMgPT09IFwiKVwiKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcblx0XHRcdFx0XHRcdHN0YXRlID0gXCJpbiBkZXNjcmlwdG9yXCI7XG5cblx0XHRcdFx0XHRcdC8vIEVPRlxuXHRcdFx0XHRcdFx0Ly8gQXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0byBkZXNjcmlwdG9ycy4gSnVtcCB0byB0aGUgc3RlcCBsYWJlbGVkXG5cdFx0XHRcdFx0XHQvLyBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuXHRcdFx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlXG5cdFx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFmdGVyIGRlc2NyaXB0b3Jcblx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJhZnRlciBkZXNjcmlwdG9yXCIpIHtcblxuXHRcdFx0XHRcdC8vIERvIHRoZSBmb2xsb3dpbmcsIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgYzpcblx0XHRcdFx0XHQvLyBTcGFjZSBjaGFyYWN0ZXI6IFN0YXkgaW4gdGhpcyBzdGF0ZS5cblx0XHRcdFx0XHRpZiAoaXNTcGFjZShjKSkge1xuXG5cdFx0XHRcdFx0XHQvLyBFT0Y6IEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZVxuXHRcdFx0XHRcdFx0Ly8gU2V0IHN0YXRlIHRvIGluIGRlc2NyaXB0b3IuIFNldCBwb3NpdGlvbiB0byB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGluIGlucHV0LlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFwiaW4gZGVzY3JpcHRvclwiO1xuXHRcdFx0XHRcdFx0cG9zIC09IDE7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZHZhbmNlIHBvc2l0aW9uIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBpbiBpbnB1dC5cblx0XHRcdFx0cG9zICs9IDE7XG5cblx0XHRcdFx0Ly8gUmVwZWF0IHRoaXMgc3RlcC5cblx0XHRcdH0gLy8gKGNsb3NlIHdoaWxlIHRydWUgbG9vcClcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBBZGRzIGRlc2NyaXB0b3IgcHJvcGVydGllcyB0byBhIGNhbmRpZGF0ZSwgcHVzaGVzIHRvIHRoZSBjYW5kaWRhdGVzIGFycmF5XG5cdFx0ICogQHJldHVybiB1bmRlZmluZWRcblx0XHQgKi9cblx0XHQvLyBEZWNsYXJlZCBvdXRzaWRlIG9mIHRoZSB3aGlsZSBsb29wIHNvIHRoYXQgaXQncyBvbmx5IGNyZWF0ZWQgb25jZS5cblx0XHRmdW5jdGlvbiBwYXJzZURlc2NyaXB0b3JzKCkge1xuXG5cdFx0XHQvLyA5LiBEZXNjcmlwdG9yIHBhcnNlcjogTGV0IGVycm9yIGJlIG5vLlxuXHRcdFx0dmFyIHBFcnJvciA9IGZhbHNlLFxuXG5cdFx0XHRcdC8vIDEwLiBMZXQgd2lkdGggYmUgYWJzZW50LlxuXHRcdFx0XHQvLyAxMS4gTGV0IGRlbnNpdHkgYmUgYWJzZW50LlxuXHRcdFx0XHQvLyAxMi4gTGV0IGZ1dHVyZS1jb21wYXQtaCBiZSBhYnNlbnQuIChXZSdyZSBpbXBsZW1lbnRpbmcgaXQgbm93IGFzIGgpXG5cdFx0XHRcdHcsIGQsIGgsIGksXG5cdFx0XHRcdGNhbmRpZGF0ZSA9IHt9LFxuXHRcdFx0XHRkZXNjLCBsYXN0Q2hhciwgdmFsdWUsIGludFZhbCwgZmxvYXRWYWw7XG5cblx0XHRcdC8vIDEzLiBGb3IgZWFjaCBkZXNjcmlwdG9yIGluIGRlc2NyaXB0b3JzLCBydW4gdGhlIGFwcHJvcHJpYXRlIHNldCBvZiBzdGVwc1xuXHRcdFx0Ly8gZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG5cdFx0XHRmb3IgKGkgPSAwIDsgaSA8IGRlc2NyaXB0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc2MgPSBkZXNjcmlwdG9yc1sgaSBdO1xuXG5cdFx0XHRcdGxhc3RDaGFyID0gZGVzY1sgZGVzYy5sZW5ndGggLSAxIF07XG5cdFx0XHRcdHZhbHVlID0gZGVzYy5zdWJzdHJpbmcoMCwgZGVzYy5sZW5ndGggLSAxKTtcblx0XHRcdFx0aW50VmFsID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcblx0XHRcdFx0ZmxvYXRWYWwgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZGVzY3JpcHRvciBjb25zaXN0cyBvZiBhIHZhbGlkIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5XG5cdFx0XHRcdC8vIGEgVSswMDc3IExBVElOIFNNQUxMIExFVFRFUiBXIGNoYXJhY3RlclxuXHRcdFx0XHRpZiAocmVnZXhOb25OZWdhdGl2ZUludGVnZXIudGVzdCh2YWx1ZSkgJiYgKGxhc3RDaGFyID09PSBcIndcIikpIHtcblxuXHRcdFx0XHRcdC8vIElmIHdpZHRoIGFuZCBkZW5zaXR5IGFyZSBub3QgYm90aCBhYnNlbnQsIHRoZW4gbGV0IGVycm9yIGJlIHllcy5cblx0XHRcdFx0XHRpZiAodyB8fCBkKSB7cEVycm9yID0gdHJ1ZTt9XG5cblx0XHRcdFx0XHQvLyBBcHBseSB0aGUgcnVsZXMgZm9yIHBhcnNpbmcgbm9uLW5lZ2F0aXZlIGludGVnZXJzIHRvIHRoZSBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdC8vIElmIHRoZSByZXN1bHQgaXMgemVybywgbGV0IGVycm9yIGJlIHllcy5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGxldCB3aWR0aCBiZSB0aGUgcmVzdWx0LlxuXHRcdFx0XHRcdGlmIChpbnRWYWwgPT09IDApIHtwRXJyb3IgPSB0cnVlO30gZWxzZSB7dyA9IGludFZhbDt9XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgZGVzY3JpcHRvciBjb25zaXN0cyBvZiBhIHZhbGlkIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb2xsb3dlZCBieVxuXHRcdFx0XHRcdC8vIGEgVSswMDc4IExBVElOIFNNQUxMIExFVFRFUiBYIGNoYXJhY3RlclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlZ2V4RmxvYXRpbmdQb2ludC50ZXN0KHZhbHVlKSAmJiAobGFzdENoYXIgPT09IFwieFwiKSkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2lkdGgsIGRlbnNpdHkgYW5kIGZ1dHVyZS1jb21wYXQtaCBhcmUgbm90IGFsbCBhYnNlbnQsIHRoZW4gbGV0IGVycm9yXG5cdFx0XHRcdFx0Ly8gYmUgeWVzLlxuXHRcdFx0XHRcdGlmICh3IHx8IGQgfHwgaCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlciB2YWx1ZXMgdG8gdGhlIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHJlc3VsdCBpcyBsZXNzIHRoYW4gemVybywgbGV0IGVycm9yIGJlIHllcy4gT3RoZXJ3aXNlLCBsZXQgZGVuc2l0eVxuXHRcdFx0XHRcdC8vIGJlIHRoZSByZXN1bHQuXG5cdFx0XHRcdFx0aWYgKGZsb2F0VmFsIDwgMCkge3BFcnJvciA9IHRydWU7fSBlbHNlIHtkID0gZmxvYXRWYWw7fVxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBub24tbmVnYXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieVxuXHRcdFx0XHRcdC8vIGEgVSswMDY4IExBVElOIFNNQUxMIExFVFRFUiBIIGNoYXJhY3RlclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlZ2V4Tm9uTmVnYXRpdmVJbnRlZ2VyLnRlc3QodmFsdWUpICYmIChsYXN0Q2hhciA9PT0gXCJoXCIpKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBoZWlnaHQgYW5kIGRlbnNpdHkgYXJlIG5vdCBib3RoIGFic2VudCwgdGhlbiBsZXQgZXJyb3IgYmUgeWVzLlxuXHRcdFx0XHRcdGlmIChoIHx8IGQpIHtwRXJyb3IgPSB0cnVlO31cblxuXHRcdFx0XHRcdC8vIEFwcGx5IHRoZSBydWxlcyBmb3IgcGFyc2luZyBub24tbmVnYXRpdmUgaW50ZWdlcnMgdG8gdGhlIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHJlc3VsdCBpcyB6ZXJvLCBsZXQgZXJyb3IgYmUgeWVzLiBPdGhlcndpc2UsIGxldCBmdXR1cmUtY29tcGF0LWhcblx0XHRcdFx0XHQvLyBiZSB0aGUgcmVzdWx0LlxuXHRcdFx0XHRcdGlmIChpbnRWYWwgPT09IDApIHtwRXJyb3IgPSB0cnVlO30gZWxzZSB7aCA9IGludFZhbDt9XG5cblx0XHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlLCBMZXQgZXJyb3IgYmUgeWVzLlxuXHRcdFx0XHR9IGVsc2Uge3BFcnJvciA9IHRydWU7fVxuXHRcdFx0fSAvLyAoY2xvc2Ugc3RlcCAxMyBmb3IgbG9vcClcblxuXHRcdFx0Ly8gMTUuIElmIGVycm9yIGlzIHN0aWxsIG5vLCB0aGVuIGFwcGVuZCBhIG5ldyBpbWFnZSBzb3VyY2UgdG8gY2FuZGlkYXRlcyB3aG9zZVxuXHRcdFx0Ly8gVVJMIGlzIHVybCwgYXNzb2NpYXRlZCB3aXRoIGEgd2lkdGggd2lkdGggaWYgbm90IGFic2VudCBhbmQgYSBwaXhlbFxuXHRcdFx0Ly8gZGVuc2l0eSBkZW5zaXR5IGlmIG5vdCBhYnNlbnQuIE90aGVyd2lzZSwgdGhlcmUgaXMgYSBwYXJzZSBlcnJvci5cblx0XHRcdGlmICghcEVycm9yKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZS51cmwgPSB1cmw7XG5cdFx0XHRcdGlmICh3KSB7IGNhbmRpZGF0ZS53ID0gdzt9XG5cdFx0XHRcdGlmIChkKSB7IGNhbmRpZGF0ZS5kID0gZDt9XG5cdFx0XHRcdGlmIChoKSB7IGNhbmRpZGF0ZS5oID0gaDt9XG5cdFx0XHRcdGNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xuXHRcdFx0fSBlbHNlIGlmIChjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiSW52YWxpZCBzcmNzZXQgZGVzY3JpcHRvciBmb3VuZCBpbiAnXCIgK1xuXHRcdFx0XHRcdGlucHV0ICsgXCInIGF0ICdcIiArIGRlc2MgKyBcIicuXCIpO1xuXHRcdFx0fVxuXHRcdH0gLy8gKGNsb3NlIHBhcnNlRGVzY3JpcHRvcnMgZm4pXG5cblx0fVxufSkpO1xuIl0sIm5hbWVzIjpbInJvb3QiLCJmYWN0b3J5IiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsInBhcnNlU3Jjc2V0IiwiaW5wdXQiLCJpc1NwYWNlIiwiYyIsImNvbGxlY3RDaGFyYWN0ZXJzIiwicmVnRXgiLCJjaGFycyIsIm1hdGNoIiwiZXhlYyIsInN1YnN0cmluZyIsInBvcyIsImxlbmd0aCIsImlucHV0TGVuZ3RoIiwicmVnZXhMZWFkaW5nU3BhY2VzIiwicmVnZXhMZWFkaW5nQ29tbWFzT3JTcGFjZXMiLCJyZWdleExlYWRpbmdOb3RTcGFjZXMiLCJyZWdleFRyYWlsaW5nQ29tbWFzIiwicmVnZXhOb25OZWdhdGl2ZUludGVnZXIiLCJyZWdleEZsb2F0aW5nUG9pbnQiLCJ1cmwiLCJkZXNjcmlwdG9ycyIsImN1cnJlbnREZXNjcmlwdG9yIiwic3RhdGUiLCJjYW5kaWRhdGVzIiwic2xpY2UiLCJyZXBsYWNlIiwicGFyc2VEZXNjcmlwdG9ycyIsInRva2VuaXplIiwiY2hhckF0IiwicHVzaCIsInBFcnJvciIsInciLCJkIiwiaCIsImkiLCJjYW5kaWRhdGUiLCJkZXNjIiwibGFzdENoYXIiLCJ2YWx1ZSIsImludFZhbCIsImZsb2F0VmFsIiwicGFyc2VJbnQiLCJwYXJzZUZsb2F0IiwidGVzdCIsImNvbnNvbGUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/parse-srcset/src/parse-srcset.js\n");

/***/ })

};
;