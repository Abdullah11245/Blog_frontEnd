/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sanitize-html";
exports.ids = ["vendor-chunks/sanitize-html"];
exports.modules = {

/***/ "(ssr)/./node_modules/sanitize-html/index.js":
/*!*********************************************!*\
  !*** ./node_modules/sanitize-html/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const htmlparser = __webpack_require__(/*! htmlparser2 */ \"(ssr)/./node_modules/htmlparser2/lib/index.js\");\nconst escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ \"(ssr)/./node_modules/escape-string-regexp/index.js\");\nconst { isPlainObject } = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nconst deepmerge = __webpack_require__(/*! deepmerge */ \"(ssr)/./node_modules/deepmerge/dist/cjs.js\");\nconst parseSrcset = __webpack_require__(/*! parse-srcset */ \"(ssr)/./node_modules/parse-srcset/src/parse-srcset.js\");\nconst { parse: postcssParse } = __webpack_require__(/*! postcss */ \"(ssr)/./node_modules/postcss/lib/postcss.js\");\n// Tags that can conceivably represent stand-alone media.\nconst mediaTags = [\n    \"img\",\n    \"audio\",\n    \"video\",\n    \"picture\",\n    \"svg\",\n    \"object\",\n    \"map\",\n    \"iframe\",\n    \"embed\"\n];\n// Tags that are inherently vulnerable to being used in XSS attacks.\nconst vulnerableTags = [\n    \"script\",\n    \"style\"\n];\nfunction each(obj, cb) {\n    if (obj) {\n        Object.keys(obj).forEach(function(key) {\n            cb(obj[key], key);\n        });\n    }\n}\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n    return ({}).hasOwnProperty.call(obj, key);\n}\n// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a, cb) {\n    const n = [];\n    each(a, function(v) {\n        if (cb(v)) {\n            n.push(v);\n        }\n    });\n    return n;\n}\nfunction isEmptyObject(obj) {\n    for(const key in obj){\n        if (has(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction stringifySrcset(parsedSrcset) {\n    return parsedSrcset.map(function(part) {\n        if (!part.url) {\n            throw new Error(\"URL missing\");\n        }\n        return part.url + (part.w ? ` ${part.w}w` : \"\") + (part.h ? ` ${part.h}h` : \"\") + (part.d ? ` ${part.d}x` : \"\");\n    }).join(\", \");\n}\nmodule.exports = sanitizeHtml;\n// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nconst VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/;\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\nfunction sanitizeHtml(html, options, _recursing) {\n    if (html == null) {\n        return \"\";\n    }\n    if (typeof html === \"number\") {\n        html = html.toString();\n    }\n    let result = \"\";\n    // Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\n    let tempResult = \"\";\n    function Frame(tag, attribs) {\n        const that = this;\n        this.tag = tag;\n        this.attribs = attribs || {};\n        this.tagPosition = result.length;\n        this.text = \"\"; // Node inner text\n        this.mediaChildren = [];\n        this.updateParentNodeText = function() {\n            if (stack.length) {\n                const parentFrame = stack[stack.length - 1];\n                parentFrame.text += that.text;\n            }\n        };\n        this.updateParentNodeMediaChildren = function() {\n            if (stack.length && mediaTags.includes(this.tag)) {\n                const parentFrame = stack[stack.length - 1];\n                parentFrame.mediaChildren.push(this.tag);\n            }\n        };\n    }\n    options = Object.assign({}, sanitizeHtml.defaults, options);\n    options.parser = Object.assign({}, htmlParserDefaults, options.parser);\n    const tagAllowed = function(name) {\n        return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;\n    };\n    // vulnerableTags\n    vulnerableTags.forEach(function(tag) {\n        if (tagAllowed(tag) && !options.allowVulnerableTags) {\n            console.warn(`\\n\\n⚠️ Your \\`allowedTags\\` option includes, \\`${tag}\\`, which is inherently\\nvulnerable to XSS attacks. Please remove it from \\`allowedTags\\`.\\nOr, to disable this warning, add the \\`allowVulnerableTags\\` option\\nand ensure you are accounting for this risk.\\n\\n`);\n        }\n    });\n    // Tags that contain something other than HTML, or where discarding\n    // the text when the tag is disallowed makes sense for other reasons.\n    // If we are not allowing these tags, we should drop their content too.\n    // For other tags you would drop the tag but keep its content.\n    const nonTextTagsArray = options.nonTextTags || [\n        \"script\",\n        \"style\",\n        \"textarea\",\n        \"option\"\n    ];\n    let allowedAttributesMap;\n    let allowedAttributesGlobMap;\n    if (options.allowedAttributes) {\n        allowedAttributesMap = {};\n        allowedAttributesGlobMap = {};\n        each(options.allowedAttributes, function(attributes, tag) {\n            allowedAttributesMap[tag] = [];\n            const globRegex = [];\n            attributes.forEach(function(obj) {\n                if (typeof obj === \"string\" && obj.indexOf(\"*\") >= 0) {\n                    globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, \".*\"));\n                } else {\n                    allowedAttributesMap[tag].push(obj);\n                }\n            });\n            if (globRegex.length) {\n                allowedAttributesGlobMap[tag] = new RegExp(\"^(\" + globRegex.join(\"|\") + \")$\");\n            }\n        });\n    }\n    const allowedClassesMap = {};\n    const allowedClassesGlobMap = {};\n    const allowedClassesRegexMap = {};\n    each(options.allowedClasses, function(classes, tag) {\n        // Implicitly allows the class attribute\n        if (allowedAttributesMap) {\n            if (!has(allowedAttributesMap, tag)) {\n                allowedAttributesMap[tag] = [];\n            }\n            allowedAttributesMap[tag].push(\"class\");\n        }\n        allowedClassesMap[tag] = classes;\n        if (Array.isArray(classes)) {\n            const globRegex = [];\n            allowedClassesMap[tag] = [];\n            allowedClassesRegexMap[tag] = [];\n            classes.forEach(function(obj) {\n                if (typeof obj === \"string\" && obj.indexOf(\"*\") >= 0) {\n                    globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, \".*\"));\n                } else if (obj instanceof RegExp) {\n                    allowedClassesRegexMap[tag].push(obj);\n                } else {\n                    allowedClassesMap[tag].push(obj);\n                }\n            });\n            if (globRegex.length) {\n                allowedClassesGlobMap[tag] = new RegExp(\"^(\" + globRegex.join(\"|\") + \")$\");\n            }\n        }\n    });\n    const transformTagsMap = {};\n    let transformTagsAll;\n    each(options.transformTags, function(transform, tag) {\n        let transFun;\n        if (typeof transform === \"function\") {\n            transFun = transform;\n        } else if (typeof transform === \"string\") {\n            transFun = sanitizeHtml.simpleTransform(transform);\n        }\n        if (tag === \"*\") {\n            transformTagsAll = transFun;\n        } else {\n            transformTagsMap[tag] = transFun;\n        }\n    });\n    let depth;\n    let stack;\n    let skipMap;\n    let transformMap;\n    let skipText;\n    let skipTextDepth;\n    let addedText = false;\n    initializeState();\n    const parser = new htmlparser.Parser({\n        onopentag: function(name, attribs) {\n            // If `enforceHtmlBoundary` is `true` and this has found the opening\n            // `html` tag, reset the state.\n            if (options.enforceHtmlBoundary && name === \"html\") {\n                initializeState();\n            }\n            if (skipText) {\n                skipTextDepth++;\n                return;\n            }\n            const frame = new Frame(name, attribs);\n            stack.push(frame);\n            let skip = false;\n            const hasText = !!frame.text;\n            let transformedTag;\n            if (has(transformTagsMap, name)) {\n                transformedTag = transformTagsMap[name](name, attribs);\n                frame.attribs = attribs = transformedTag.attribs;\n                if (transformedTag.text !== undefined) {\n                    frame.innerText = transformedTag.text;\n                }\n                if (name !== transformedTag.tagName) {\n                    frame.name = name = transformedTag.tagName;\n                    transformMap[depth] = transformedTag.tagName;\n                }\n            }\n            if (transformTagsAll) {\n                transformedTag = transformTagsAll(name, attribs);\n                frame.attribs = attribs = transformedTag.attribs;\n                if (name !== transformedTag.tagName) {\n                    frame.name = name = transformedTag.tagName;\n                    transformMap[depth] = transformedTag.tagName;\n                }\n            }\n            if (!tagAllowed(name) || options.disallowedTagsMode === \"recursiveEscape\" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {\n                skip = true;\n                skipMap[depth] = true;\n                if (options.disallowedTagsMode === \"discard\" || options.disallowedTagsMode === \"completelyDiscard\") {\n                    if (nonTextTagsArray.indexOf(name) !== -1) {\n                        skipText = true;\n                        skipTextDepth = 1;\n                    }\n                }\n                skipMap[depth] = true;\n            }\n            depth++;\n            if (skip) {\n                if (options.disallowedTagsMode === \"discard\" || options.disallowedTagsMode === \"completelyDiscard\") {\n                    // We want the contents but not this tag\n                    return;\n                }\n                tempResult = result;\n                result = \"\";\n            }\n            result += \"<\" + name;\n            if (name === \"script\") {\n                if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n                    frame.innerText = \"\";\n                }\n            }\n            if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap[\"*\"]) {\n                each(attribs, function(value, a) {\n                    if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n                        // This prevents part of an attribute name in the output from being\n                        // interpreted as the end of an attribute, or end of a tag.\n                        delete frame.attribs[a];\n                        return;\n                    }\n                    // If the value is empty, check if the attribute is in the allowedEmptyAttributes array.\n                    // If it is not in the allowedEmptyAttributes array, and it is a known non-boolean attribute, delete it\n                    // List taken from https://html.spec.whatwg.org/multipage/indices.html#attributes-3\n                    if (value === \"\" && !options.allowedEmptyAttributes.includes(a) && (options.nonBooleanAttributes.includes(a) || options.nonBooleanAttributes.includes(\"*\"))) {\n                        delete frame.attribs[a];\n                        return;\n                    }\n                    // check allowedAttributesMap for the element and attribute and modify the value\n                    // as necessary if there are specific values defined.\n                    let passedAllowedAttributesMapCheck = false;\n                    if (!allowedAttributesMap || has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 || allowedAttributesMap[\"*\"] && allowedAttributesMap[\"*\"].indexOf(a) !== -1 || has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a) || allowedAttributesGlobMap[\"*\"] && allowedAttributesGlobMap[\"*\"].test(a)) {\n                        passedAllowedAttributesMapCheck = true;\n                    } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n                        for (const o of allowedAttributesMap[name]){\n                            if (isPlainObject(o) && o.name && o.name === a) {\n                                passedAllowedAttributesMapCheck = true;\n                                let newValue = \"\";\n                                if (o.multiple === true) {\n                                    // verify the values that are allowed\n                                    const splitStrArray = value.split(\" \");\n                                    for (const s of splitStrArray){\n                                        if (o.values.indexOf(s) !== -1) {\n                                            if (newValue === \"\") {\n                                                newValue = s;\n                                            } else {\n                                                newValue += \" \" + s;\n                                            }\n                                        }\n                                    }\n                                } else if (o.values.indexOf(value) >= 0) {\n                                    // verified an allowed value matches the entire attribute value\n                                    newValue = value;\n                                }\n                                value = newValue;\n                            }\n                        }\n                    }\n                    if (passedAllowedAttributesMapCheck) {\n                        if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n                            if (naughtyHref(name, value)) {\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (name === \"script\" && a === \"src\") {\n                            let allowed = true;\n                            try {\n                                const parsed = parseUrl(value);\n                                if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n                                    const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {\n                                        return hostname === parsed.url.hostname;\n                                    });\n                                    const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {\n                                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                                    });\n                                    allowed = allowedHostname || allowedDomain;\n                                }\n                            } catch (e) {\n                                allowed = false;\n                            }\n                            if (!allowed) {\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (name === \"iframe\" && a === \"src\") {\n                            let allowed = true;\n                            try {\n                                const parsed = parseUrl(value);\n                                if (parsed.isRelativeUrl) {\n                                    // default value of allowIframeRelativeUrls is true\n                                    // unless allowedIframeHostnames or allowedIframeDomains specified\n                                    allowed = has(options, \"allowIframeRelativeUrls\") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;\n                                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {\n                                    const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {\n                                        return hostname === parsed.url.hostname;\n                                    });\n                                    const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {\n                                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                                    });\n                                    allowed = allowedHostname || allowedDomain;\n                                }\n                            } catch (e) {\n                                // Unparseable iframe src\n                                allowed = false;\n                            }\n                            if (!allowed) {\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (a === \"srcset\") {\n                            try {\n                                let parsed = parseSrcset(value);\n                                parsed.forEach(function(value) {\n                                    if (naughtyHref(\"srcset\", value.url)) {\n                                        value.evil = true;\n                                    }\n                                });\n                                parsed = filter(parsed, function(v) {\n                                    return !v.evil;\n                                });\n                                if (!parsed.length) {\n                                    delete frame.attribs[a];\n                                    return;\n                                } else {\n                                    value = stringifySrcset(filter(parsed, function(v) {\n                                        return !v.evil;\n                                    }));\n                                    frame.attribs[a] = value;\n                                }\n                            } catch (e) {\n                                // Unparseable srcset\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (a === \"class\") {\n                            const allowedSpecificClasses = allowedClassesMap[name];\n                            const allowedWildcardClasses = allowedClassesMap[\"*\"];\n                            const allowedSpecificClassesGlob = allowedClassesGlobMap[name];\n                            const allowedSpecificClassesRegex = allowedClassesRegexMap[name];\n                            const allowedWildcardClassesGlob = allowedClassesGlobMap[\"*\"];\n                            const allowedClassesGlobs = [\n                                allowedSpecificClassesGlob,\n                                allowedWildcardClassesGlob\n                            ].concat(allowedSpecificClassesRegex).filter(function(t) {\n                                return t;\n                            });\n                            if (allowedSpecificClasses && allowedWildcardClasses) {\n                                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);\n                            } else {\n                                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);\n                            }\n                            if (!value.length) {\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (a === \"style\") {\n                            if (options.parseStyleAttributes) {\n                                try {\n                                    const abstractSyntaxTree = postcssParse(name + \" {\" + value + \"}\", {\n                                        map: false\n                                    });\n                                    const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n                                    value = stringifyStyleAttributes(filteredAST);\n                                    if (value.length === 0) {\n                                        delete frame.attribs[a];\n                                        return;\n                                    }\n                                } catch (e) {\n                                    if (false) {}\n                                    delete frame.attribs[a];\n                                    return;\n                                }\n                            } else if (options.allowedStyles) {\n                                throw new Error(\"allowedStyles option cannot be used together with parseStyleAttributes: false.\");\n                            }\n                        }\n                        result += \" \" + a;\n                        if (value && value.length) {\n                            result += '=\"' + escapeHtml(value, true) + '\"';\n                        } else if (options.allowedEmptyAttributes.includes(a)) {\n                            result += '=\"\"';\n                        }\n                    } else {\n                        delete frame.attribs[a];\n                    }\n                });\n            }\n            if (options.selfClosing.indexOf(name) !== -1) {\n                result += \" />\";\n            } else {\n                result += \">\";\n                if (frame.innerText && !hasText && !options.textFilter) {\n                    result += escapeHtml(frame.innerText);\n                    addedText = true;\n                }\n            }\n            if (skip) {\n                result = tempResult + escapeHtml(result);\n                tempResult = \"\";\n            }\n        },\n        ontext: function(text) {\n            if (skipText) {\n                return;\n            }\n            const lastFrame = stack[stack.length - 1];\n            let tag;\n            if (lastFrame) {\n                tag = lastFrame.tag;\n                // If inner text was set by transform function then let's use it\n                text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n            }\n            if (options.disallowedTagsMode === \"completelyDiscard\" && !tagAllowed(tag)) {\n                text = \"\";\n            } else if ((options.disallowedTagsMode === \"discard\" || options.disallowedTagsMode === \"completelyDiscard\") && (tag === \"script\" || tag === \"style\")) {\n                // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n                // script tags is, by definition, game over for XSS protection, so if that's\n                // your concern, don't allow them. The same is essentially true for style tags\n                // which have their own collection of XSS vectors.\n                result += text;\n            } else {\n                const escaped = escapeHtml(text, false);\n                if (options.textFilter && !addedText) {\n                    result += options.textFilter(escaped, tag);\n                } else if (!addedText) {\n                    result += escaped;\n                }\n            }\n            if (stack.length) {\n                const frame = stack[stack.length - 1];\n                frame.text += text;\n            }\n        },\n        onclosetag: function(name, isImplied) {\n            if (skipText) {\n                skipTextDepth--;\n                if (!skipTextDepth) {\n                    skipText = false;\n                } else {\n                    return;\n                }\n            }\n            const frame = stack.pop();\n            if (!frame) {\n                // Do not crash on bad markup\n                return;\n            }\n            if (frame.tag !== name) {\n                // Another case of bad markup.\n                // Push to stack, so that it will be used in future closing tags.\n                stack.push(frame);\n                return;\n            }\n            skipText = options.enforceHtmlBoundary ? name === \"html\" : false;\n            depth--;\n            const skip = skipMap[depth];\n            if (skip) {\n                delete skipMap[depth];\n                if (options.disallowedTagsMode === \"discard\" || options.disallowedTagsMode === \"completelyDiscard\") {\n                    frame.updateParentNodeText();\n                    return;\n                }\n                tempResult = result;\n                result = \"\";\n            }\n            if (transformMap[depth]) {\n                name = transformMap[depth];\n                delete transformMap[depth];\n            }\n            if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n                result = result.substr(0, frame.tagPosition);\n                return;\n            }\n            frame.updateParentNodeMediaChildren();\n            frame.updateParentNodeText();\n            if (// Already output />\n            options.selfClosing.indexOf(name) !== -1 || // Escaped tag, closing tag is implied\n            isImplied && !tagAllowed(name) && [\n                \"escape\",\n                \"recursiveEscape\"\n            ].indexOf(options.disallowedTagsMode) >= 0) {\n                if (skip) {\n                    result = tempResult;\n                    tempResult = \"\";\n                }\n                return;\n            }\n            result += \"</\" + name + \">\";\n            if (skip) {\n                result = tempResult + escapeHtml(result);\n                tempResult = \"\";\n            }\n            addedText = false;\n        }\n    }, options.parser);\n    parser.write(html);\n    parser.end();\n    return result;\n    function initializeState() {\n        result = \"\";\n        depth = 0;\n        stack = [];\n        skipMap = {};\n        transformMap = {};\n        skipText = false;\n        skipTextDepth = 0;\n    }\n    function escapeHtml(s, quote) {\n        if (typeof s !== \"string\") {\n            s = s + \"\";\n        }\n        if (options.parser.decodeEntities) {\n            s = s.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n            if (quote) {\n                s = s.replace(/\"/g, \"&quot;\");\n            }\n        }\n        // TODO: this is inadequate because it will pass `&0;`. This approach\n        // will not work, each & must be considered with regard to whether it\n        // is followed by a 100% syntactically valid entity or not, and escaped\n        // if it is not. If this bothers you, don't set parser.decodeEntities\n        // to false. (The default is true.)\n        s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, \"&amp;\") // Match ampersands not part of existing HTML entity\n        .replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        if (quote) {\n            s = s.replace(/\"/g, \"&quot;\");\n        }\n        return s;\n    }\n    function naughtyHref(name, href) {\n        // Browsers ignore character codes of 32 (space) and below in a surprising\n        // number of situations. Start reading here:\n        // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n        // eslint-disable-next-line no-control-regex\n        href = href.replace(/[\\x00-\\x20]+/g, \"\");\n        // Clobber any comments in URLs, which the browser might\n        // interpret inside an XML data island, allowing\n        // a javascript: URL to be snuck through\n        while(true){\n            const firstIndex = href.indexOf(\"<!--\");\n            if (firstIndex === -1) {\n                break;\n            }\n            const lastIndex = href.indexOf(\"-->\", firstIndex + 4);\n            if (lastIndex === -1) {\n                break;\n            }\n            href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);\n        }\n        // Case insensitive so we don't get faked out by JAVASCRIPT #1\n        // Allow more characters after the first so we don't get faked\n        // out by certain schemes browsers accept\n        const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\\-+]*):/);\n        if (!matches) {\n            // Protocol-relative URL starting with any combination of '/' and '\\'\n            if (href.match(/^[/\\\\]{2}/)) {\n                return !options.allowProtocolRelative;\n            }\n            // No scheme\n            return false;\n        }\n        const scheme = matches[1].toLowerCase();\n        if (has(options.allowedSchemesByTag, name)) {\n            return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n        }\n        return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n    }\n    function parseUrl(value) {\n        value = value.replace(/^(\\w+:)?\\s*[\\\\/]\\s*[\\\\/]/, \"$1//\");\n        if (value.startsWith(\"relative:\")) {\n            // An attempt to exploit our workaround for base URLs being\n            // mandatory for relative URL validation in the WHATWG\n            // URL parser, reject it\n            throw new Error(\"relative: exploit attempt\");\n        }\n        // naughtyHref is in charge of whether protocol relative URLs\n        // are cool. Here we are concerned just with allowed hostnames and\n        // whether to allow relative URLs.\n        //\n        // Build a placeholder \"base URL\" against which any reasonable\n        // relative URL may be parsed successfully\n        let base = \"relative://relative-site\";\n        for(let i = 0; i < 100; i++){\n            base += `/${i}`;\n        }\n        const parsed = new URL(value, base);\n        const isRelativeUrl = parsed && parsed.hostname === \"relative-site\" && parsed.protocol === \"relative:\";\n        return {\n            isRelativeUrl,\n            url: parsed\n        };\n    }\n    /**\n   * Filters user input css properties by allowlisted regex attributes.\n   * Modifies the abstractSyntaxTree object.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - The modified tree.\n   */ function filterCss(abstractSyntaxTree, allowedStyles) {\n        if (!allowedStyles) {\n            return abstractSyntaxTree;\n        }\n        const astRules = abstractSyntaxTree.nodes[0];\n        let selectedRule;\n        // Merge global and tag-specific styles into new AST.\n        if (allowedStyles[astRules.selector] && allowedStyles[\"*\"]) {\n            selectedRule = deepmerge(allowedStyles[astRules.selector], allowedStyles[\"*\"]);\n        } else {\n            selectedRule = allowedStyles[astRules.selector] || allowedStyles[\"*\"];\n        }\n        if (selectedRule) {\n            abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n        }\n        return abstractSyntaxTree;\n    }\n    /**\n   * Extracts the style attributes from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center !important;font-family:helvetica;\"\n   */ function stringifyStyleAttributes(filteredAST) {\n        return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {\n            extractedAttributes.push(`${attrObject.prop}:${attrObject.value}${attrObject.important ? \" !important\" : \"\"}`);\n            return extractedAttributes;\n        }, []).join(\";\");\n    }\n    /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the allowlist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */ function filterDeclarations(selectedRule) {\n        return function(allowedDeclarationsList, attributeObject) {\n            // If this property is allowlisted...\n            if (has(selectedRule, attributeObject.prop)) {\n                const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {\n                    return regularExpression.test(attributeObject.value);\n                });\n                if (matchesRegex) {\n                    allowedDeclarationsList.push(attributeObject);\n                }\n            }\n            return allowedDeclarationsList;\n        };\n    }\n    function filterClasses(classes, allowed, allowedGlobs) {\n        if (!allowed) {\n            // The class attribute is allowed without filtering on this tag\n            return classes;\n        }\n        classes = classes.split(/\\s+/);\n        return classes.filter(function(clss) {\n            return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {\n                return glob.test(clss);\n            });\n        }).join(\" \");\n    }\n}\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\nconst htmlParserDefaults = {\n    decodeEntities: true\n};\nsanitizeHtml.defaults = {\n    allowedTags: [\n        // Sections derived from MDN element categories and limited to the more\n        // benign categories.\n        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n        // Content sectioning\n        \"address\",\n        \"article\",\n        \"aside\",\n        \"footer\",\n        \"header\",\n        \"h1\",\n        \"h2\",\n        \"h3\",\n        \"h4\",\n        \"h5\",\n        \"h6\",\n        \"hgroup\",\n        \"main\",\n        \"nav\",\n        \"section\",\n        // Text content\n        \"blockquote\",\n        \"dd\",\n        \"div\",\n        \"dl\",\n        \"dt\",\n        \"figcaption\",\n        \"figure\",\n        \"hr\",\n        \"li\",\n        \"main\",\n        \"ol\",\n        \"p\",\n        \"pre\",\n        \"ul\",\n        // Inline text semantics\n        \"a\",\n        \"abbr\",\n        \"b\",\n        \"bdi\",\n        \"bdo\",\n        \"br\",\n        \"cite\",\n        \"code\",\n        \"data\",\n        \"dfn\",\n        \"em\",\n        \"i\",\n        \"kbd\",\n        \"mark\",\n        \"q\",\n        \"rb\",\n        \"rp\",\n        \"rt\",\n        \"rtc\",\n        \"ruby\",\n        \"s\",\n        \"samp\",\n        \"small\",\n        \"span\",\n        \"strong\",\n        \"sub\",\n        \"sup\",\n        \"time\",\n        \"u\",\n        \"var\",\n        \"wbr\",\n        // Table content\n        \"caption\",\n        \"col\",\n        \"colgroup\",\n        \"table\",\n        \"tbody\",\n        \"td\",\n        \"tfoot\",\n        \"th\",\n        \"thead\",\n        \"tr\"\n    ],\n    // Tags that cannot be boolean\n    nonBooleanAttributes: [\n        \"abbr\",\n        \"accept\",\n        \"accept-charset\",\n        \"accesskey\",\n        \"action\",\n        \"allow\",\n        \"alt\",\n        \"as\",\n        \"autocapitalize\",\n        \"autocomplete\",\n        \"blocking\",\n        \"charset\",\n        \"cite\",\n        \"class\",\n        \"color\",\n        \"cols\",\n        \"colspan\",\n        \"content\",\n        \"contenteditable\",\n        \"coords\",\n        \"crossorigin\",\n        \"data\",\n        \"datetime\",\n        \"decoding\",\n        \"dir\",\n        \"dirname\",\n        \"download\",\n        \"draggable\",\n        \"enctype\",\n        \"enterkeyhint\",\n        \"fetchpriority\",\n        \"for\",\n        \"form\",\n        \"formaction\",\n        \"formenctype\",\n        \"formmethod\",\n        \"formtarget\",\n        \"headers\",\n        \"height\",\n        \"hidden\",\n        \"high\",\n        \"href\",\n        \"hreflang\",\n        \"http-equiv\",\n        \"id\",\n        \"imagesizes\",\n        \"imagesrcset\",\n        \"inputmode\",\n        \"integrity\",\n        \"is\",\n        \"itemid\",\n        \"itemprop\",\n        \"itemref\",\n        \"itemtype\",\n        \"kind\",\n        \"label\",\n        \"lang\",\n        \"list\",\n        \"loading\",\n        \"low\",\n        \"max\",\n        \"maxlength\",\n        \"media\",\n        \"method\",\n        \"min\",\n        \"minlength\",\n        \"name\",\n        \"nonce\",\n        \"optimum\",\n        \"pattern\",\n        \"ping\",\n        \"placeholder\",\n        \"popover\",\n        \"popovertarget\",\n        \"popovertargetaction\",\n        \"poster\",\n        \"preload\",\n        \"referrerpolicy\",\n        \"rel\",\n        \"rows\",\n        \"rowspan\",\n        \"sandbox\",\n        \"scope\",\n        \"shape\",\n        \"size\",\n        \"sizes\",\n        \"slot\",\n        \"span\",\n        \"spellcheck\",\n        \"src\",\n        \"srcdoc\",\n        \"srclang\",\n        \"srcset\",\n        \"start\",\n        \"step\",\n        \"style\",\n        \"tabindex\",\n        \"target\",\n        \"title\",\n        \"translate\",\n        \"type\",\n        \"usemap\",\n        \"value\",\n        \"width\",\n        \"wrap\",\n        // Event handlers\n        \"onauxclick\",\n        \"onafterprint\",\n        \"onbeforematch\",\n        \"onbeforeprint\",\n        \"onbeforeunload\",\n        \"onbeforetoggle\",\n        \"onblur\",\n        \"oncancel\",\n        \"oncanplay\",\n        \"oncanplaythrough\",\n        \"onchange\",\n        \"onclick\",\n        \"onclose\",\n        \"oncontextlost\",\n        \"oncontextmenu\",\n        \"oncontextrestored\",\n        \"oncopy\",\n        \"oncuechange\",\n        \"oncut\",\n        \"ondblclick\",\n        \"ondrag\",\n        \"ondragend\",\n        \"ondragenter\",\n        \"ondragleave\",\n        \"ondragover\",\n        \"ondragstart\",\n        \"ondrop\",\n        \"ondurationchange\",\n        \"onemptied\",\n        \"onended\",\n        \"onerror\",\n        \"onfocus\",\n        \"onformdata\",\n        \"onhashchange\",\n        \"oninput\",\n        \"oninvalid\",\n        \"onkeydown\",\n        \"onkeypress\",\n        \"onkeyup\",\n        \"onlanguagechange\",\n        \"onload\",\n        \"onloadeddata\",\n        \"onloadedmetadata\",\n        \"onloadstart\",\n        \"onmessage\",\n        \"onmessageerror\",\n        \"onmousedown\",\n        \"onmouseenter\",\n        \"onmouseleave\",\n        \"onmousemove\",\n        \"onmouseout\",\n        \"onmouseover\",\n        \"onmouseup\",\n        \"onoffline\",\n        \"ononline\",\n        \"onpagehide\",\n        \"onpageshow\",\n        \"onpaste\",\n        \"onpause\",\n        \"onplay\",\n        \"onplaying\",\n        \"onpopstate\",\n        \"onprogress\",\n        \"onratechange\",\n        \"onreset\",\n        \"onresize\",\n        \"onrejectionhandled\",\n        \"onscroll\",\n        \"onscrollend\",\n        \"onsecuritypolicyviolation\",\n        \"onseeked\",\n        \"onseeking\",\n        \"onselect\",\n        \"onslotchange\",\n        \"onstalled\",\n        \"onstorage\",\n        \"onsubmit\",\n        \"onsuspend\",\n        \"ontimeupdate\",\n        \"ontoggle\",\n        \"onunhandledrejection\",\n        \"onunload\",\n        \"onvolumechange\",\n        \"onwaiting\",\n        \"onwheel\"\n    ],\n    disallowedTagsMode: \"discard\",\n    allowedAttributes: {\n        a: [\n            \"href\",\n            \"name\",\n            \"target\"\n        ],\n        // We don't currently allow img itself by default, but\n        // these attributes would make sense if we did.\n        img: [\n            \"src\",\n            \"srcset\",\n            \"alt\",\n            \"title\",\n            \"width\",\n            \"height\",\n            \"loading\"\n        ]\n    },\n    allowedEmptyAttributes: [\n        \"alt\"\n    ],\n    // Lots of these won't come up by default because we don't allow them\n    selfClosing: [\n        \"img\",\n        \"br\",\n        \"hr\",\n        \"area\",\n        \"base\",\n        \"basefont\",\n        \"input\",\n        \"link\",\n        \"meta\"\n    ],\n    // URL schemes we permit\n    allowedSchemes: [\n        \"http\",\n        \"https\",\n        \"ftp\",\n        \"mailto\",\n        \"tel\"\n    ],\n    allowedSchemesByTag: {},\n    allowedSchemesAppliedToAttributes: [\n        \"href\",\n        \"src\",\n        \"cite\"\n    ],\n    allowProtocolRelative: true,\n    enforceHtmlBoundary: false,\n    parseStyleAttributes: true\n};\nsanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {\n    merge = merge === undefined ? true : merge;\n    newAttribs = newAttribs || {};\n    return function(tagName, attribs) {\n        let attrib;\n        if (merge) {\n            for(attrib in newAttribs){\n                attribs[attrib] = newAttribs[attrib];\n            }\n        } else {\n            attribs = newAttribs;\n        }\n        return {\n            tagName: newTagName,\n            attribs: attribs\n        };\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2FuaXRpemUtaHRtbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDO0FBQ25DLE1BQU0sRUFBRUUsYUFBYSxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1HLFlBQVlILG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU0sRUFBRUssT0FBT0MsWUFBWSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ3hDLHlEQUF5RDtBQUN6RCxNQUFNTyxZQUFZO0lBQ2hCO0lBQU87SUFBUztJQUFTO0lBQVc7SUFDcEM7SUFBVTtJQUFPO0lBQVU7Q0FDNUI7QUFDRCxvRUFBb0U7QUFDcEUsTUFBTUMsaUJBQWlCO0lBQUU7SUFBVTtDQUFTO0FBRTVDLFNBQVNDLEtBQUtDLEdBQUcsRUFBRUMsRUFBRTtJQUNuQixJQUFJRCxLQUFLO1FBQ1BFLE9BQU9DLElBQUksQ0FBQ0gsS0FBS0ksT0FBTyxDQUFDLFNBQVVDLEdBQUc7WUFDcENKLEdBQUdELEdBQUcsQ0FBQ0ssSUFBSSxFQUFFQTtRQUNmO0lBQ0Y7QUFDRjtBQUVBLCtEQUErRDtBQUMvRCxTQUFTQyxJQUFJTixHQUFHLEVBQUVLLEdBQUc7SUFDbkIsT0FBTyxDQUFDLENBQUMsR0FBR0UsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEtBQUtLO0FBQ3ZDO0FBRUEsaUVBQWlFO0FBQ2pFLFNBQVNJLE9BQU9DLENBQUMsRUFBRVQsRUFBRTtJQUNuQixNQUFNVSxJQUFJLEVBQUU7SUFDWlosS0FBS1csR0FBRyxTQUFTRSxDQUFDO1FBQ2hCLElBQUlYLEdBQUdXLElBQUk7WUFDVEQsRUFBRUUsSUFBSSxDQUFDRDtRQUNUO0lBQ0Y7SUFDQSxPQUFPRDtBQUNUO0FBRUEsU0FBU0csY0FBY2QsR0FBRztJQUN4QixJQUFLLE1BQU1LLE9BQU9MLElBQUs7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QjtBQUN4QjtBQUVBakgsYUFBYXFELGVBQWUsR0FBRyxTQUFTb0gsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLEtBQUs7SUFDbkVBLFFBQVEsVUFBV3ZHLFlBQWEsT0FBT3VHO0lBQ3ZDRCxhQUFhQSxjQUFjLENBQUM7SUFFNUIsT0FBTyxTQUFTcEcsT0FBTyxFQUFFNUQsT0FBTztRQUM5QixJQUFJa0s7UUFDSixJQUFJRCxPQUFPO1lBQ1QsSUFBS0MsVUFBVUYsV0FBWTtnQkFDekJoSyxPQUFPLENBQUNrSyxPQUFPLEdBQUdGLFVBQVUsQ0FBQ0UsT0FBTztZQUN0QztRQUNGLE9BQU87WUFDTGxLLFVBQVVnSztRQUNaO1FBRUEsT0FBTztZQUNMcEcsU0FBU21HO1lBQ1QvSixTQUFTQTtRQUNYO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Jsb2cvLi9ub2RlX21vZHVsZXMvc2FuaXRpemUtaHRtbC9pbmRleC5qcz9kNTYzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGh0bWxwYXJzZXIgPSByZXF1aXJlKCdodG1scGFyc2VyMicpO1xuY29uc3QgZXNjYXBlU3RyaW5nUmVnZXhwID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcbmNvbnN0IHsgaXNQbGFpbk9iamVjdCB9ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG5jb25zdCBkZWVwbWVyZ2UgPSByZXF1aXJlKCdkZWVwbWVyZ2UnKTtcbmNvbnN0IHBhcnNlU3Jjc2V0ID0gcmVxdWlyZSgncGFyc2Utc3Jjc2V0Jyk7XG5jb25zdCB7IHBhcnNlOiBwb3N0Y3NzUGFyc2UgfSA9IHJlcXVpcmUoJ3Bvc3Rjc3MnKTtcbi8vIFRhZ3MgdGhhdCBjYW4gY29uY2VpdmFibHkgcmVwcmVzZW50IHN0YW5kLWFsb25lIG1lZGlhLlxuY29uc3QgbWVkaWFUYWdzID0gW1xuICAnaW1nJywgJ2F1ZGlvJywgJ3ZpZGVvJywgJ3BpY3R1cmUnLCAnc3ZnJyxcbiAgJ29iamVjdCcsICdtYXAnLCAnaWZyYW1lJywgJ2VtYmVkJ1xuXTtcbi8vIFRhZ3MgdGhhdCBhcmUgaW5oZXJlbnRseSB2dWxuZXJhYmxlIHRvIGJlaW5nIHVzZWQgaW4gWFNTIGF0dGFja3MuXG5jb25zdCB2dWxuZXJhYmxlVGFncyA9IFsgJ3NjcmlwdCcsICdzdHlsZScgXTtcblxuZnVuY3Rpb24gZWFjaChvYmosIGNiKSB7XG4gIGlmIChvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgY2Iob2JqW2tleV0sIGtleSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gQXZvaWQgZmFsc2UgcG9zaXRpdmVzIHdpdGggLl9fcHJvdG9fXywgLmhhc093blByb3BlcnR5LCBldGMuXG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbi8vIFJldHVybnMgdGhvc2UgZWxlbWVudHMgb2YgYGFgIGZvciB3aGljaCBgY2IoYSlgIHJldHVybnMgdHJ1dGh5XG5mdW5jdGlvbiBmaWx0ZXIoYSwgY2IpIHtcbiAgY29uc3QgbiA9IFtdO1xuICBlYWNoKGEsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoY2IodikpIHtcbiAgICAgIG4ucHVzaCh2KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcyhvYmosIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVNyY3NldChwYXJzZWRTcmNzZXQpIHtcbiAgcmV0dXJuIHBhcnNlZFNyY3NldC5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgIGlmICghcGFydC51cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVVJMIG1pc3NpbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgcGFydC51cmwgK1xuICAgICAgKHBhcnQudyA/IGAgJHtwYXJ0Lnd9d2AgOiAnJykgK1xuICAgICAgKHBhcnQuaCA/IGAgJHtwYXJ0Lmh9aGAgOiAnJykgK1xuICAgICAgKHBhcnQuZCA/IGAgJHtwYXJ0LmR9eGAgOiAnJylcbiAgICApO1xuICB9KS5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhbml0aXplSHRtbDtcblxuLy8gQSB2YWxpZCBhdHRyaWJ1dGUgbmFtZS5cbi8vIFdlIHVzZSBhIHRvbGVyYW50IGRlZmluaXRpb24gYmFzZWQgb24gdGhlIHNldCBvZiBzdHJpbmdzIGRlZmluZWQgYnlcbi8vIGh0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjYmVmb3JlLWF0dHJpYnV0ZS1uYW1lLXN0YXRlXG4vLyBhbmQgaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNhdHRyaWJ1dGUtbmFtZS1zdGF0ZSAuXG4vLyBUaGUgY2hhcmFjdGVycyBhY2NlcHRlZCBhcmUgb25lcyB3aGljaCBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIGF0dHJpYnV0ZVxuLy8gbmFtZSBidWZmZXIgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcGFyc2UgZXJyb3I6XG4vLyAgICogdW5leHBlY3RlZC1lcXVhbHMtc2lnbi1iZWZvcmUtYXR0cmlidXRlLW5hbWVcbi8vICAgKiB1bmV4cGVjdGVkLW51bGwtY2hhcmFjdGVyXG4vLyAgICogdW5leHBlY3RlZC1jaGFyYWN0ZXItaW4tYXR0cmlidXRlLW5hbWVcbi8vIFdlIGV4Y2x1ZGUgdGhlIGVtcHR5IHN0cmluZyBiZWNhdXNlIGl0J3MgaW1wb3NzaWJsZSB0byBnZXQgdG8gdGhlIGFmdGVyXG4vLyBhdHRyaWJ1dGUgbmFtZSBzdGF0ZSB3aXRoIGFuIGVtcHR5IGF0dHJpYnV0ZSBuYW1lIGJ1ZmZlci5cbmNvbnN0IFZBTElEX0hUTUxfQVRUUklCVVRFX05BTUUgPSAvXlteXFwwXFx0XFxuXFxmXFxyIC88PT5dKyQvO1xuXG4vLyBJZ25vcmUgdGhlIF9yZWN1cnNpbmcgZmxhZzsgaXQncyB0aGVyZSBmb3IgcmVjdXJzaXZlXG4vLyBpbnZvY2F0aW9uIGFzIGEgZ3VhcmQgYWdhaW5zdCB0aGlzIGV4cGxvaXQ6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmI1NS9odG1scGFyc2VyMi9pc3N1ZXMvMTA1XG5cbmZ1bmN0aW9uIHNhbml0aXplSHRtbChodG1sLCBvcHRpb25zLCBfcmVjdXJzaW5nKSB7XG4gIGlmIChodG1sID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKHR5cGVvZiBodG1sID09PSAnbnVtYmVyJykge1xuICAgIGh0bWwgPSBodG1sLnRvU3RyaW5nKCk7XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIC8vIFVzZWQgZm9yIGhvdCBzd2FwcGluZyB0aGUgcmVzdWx0IHZhcmlhYmxlIHdpdGggYW4gZW1wdHkgc3RyaW5nIGluIG9yZGVyIHRvIFwiY2FwdHVyZVwiIHRoZSB0ZXh0IHdyaXR0ZW4gdG8gaXQuXG4gIGxldCB0ZW1wUmVzdWx0ID0gJyc7XG5cbiAgZnVuY3Rpb24gRnJhbWUodGFnLCBhdHRyaWJzKSB7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy50YWcgPSB0YWc7XG4gICAgdGhpcy5hdHRyaWJzID0gYXR0cmlicyB8fCB7fTtcbiAgICB0aGlzLnRhZ1Bvc2l0aW9uID0gcmVzdWx0Lmxlbmd0aDtcbiAgICB0aGlzLnRleHQgPSAnJzsgLy8gTm9kZSBpbm5lciB0ZXh0XG4gICAgdGhpcy5tZWRpYUNoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLnVwZGF0ZVBhcmVudE5vZGVUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEZyYW1lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHBhcmVudEZyYW1lLnRleHQgKz0gdGhhdC50ZXh0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZVBhcmVudE5vZGVNZWRpYUNoaWxkcmVuID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhY2subGVuZ3RoICYmIG1lZGlhVGFncy5pbmNsdWRlcyh0aGlzLnRhZykpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RnJhbWUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgcGFyZW50RnJhbWUubWVkaWFDaGlsZHJlbi5wdXNoKHRoaXMudGFnKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHNhbml0aXplSHRtbC5kZWZhdWx0cywgb3B0aW9ucyk7XG4gIG9wdGlvbnMucGFyc2VyID0gT2JqZWN0LmFzc2lnbih7fSwgaHRtbFBhcnNlckRlZmF1bHRzLCBvcHRpb25zLnBhcnNlcik7XG5cbiAgY29uc3QgdGFnQWxsb3dlZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYWxsb3dlZFRhZ3MgPT09IGZhbHNlIHx8IChvcHRpb25zLmFsbG93ZWRUYWdzIHx8IFtdKS5pbmRleE9mKG5hbWUpID4gLTE7XG4gIH07XG5cbiAgLy8gdnVsbmVyYWJsZVRhZ3NcbiAgdnVsbmVyYWJsZVRhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgaWYgKHRhZ0FsbG93ZWQodGFnKSAmJiAhb3B0aW9ucy5hbGxvd1Z1bG5lcmFibGVUYWdzKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFxcblxcbuKaoO+4jyBZb3VyIFxcYGFsbG93ZWRUYWdzXFxgIG9wdGlvbiBpbmNsdWRlcywgXFxgJHt0YWd9XFxgLCB3aGljaCBpcyBpbmhlcmVudGx5XFxudnVsbmVyYWJsZSB0byBYU1MgYXR0YWNrcy4gUGxlYXNlIHJlbW92ZSBpdCBmcm9tIFxcYGFsbG93ZWRUYWdzXFxgLlxcbk9yLCB0byBkaXNhYmxlIHRoaXMgd2FybmluZywgYWRkIHRoZSBcXGBhbGxvd1Z1bG5lcmFibGVUYWdzXFxgIG9wdGlvblxcbmFuZCBlbnN1cmUgeW91IGFyZSBhY2NvdW50aW5nIGZvciB0aGlzIHJpc2suXFxuXFxuYCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUYWdzIHRoYXQgY29udGFpbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBIVE1MLCBvciB3aGVyZSBkaXNjYXJkaW5nXG4gIC8vIHRoZSB0ZXh0IHdoZW4gdGhlIHRhZyBpcyBkaXNhbGxvd2VkIG1ha2VzIHNlbnNlIGZvciBvdGhlciByZWFzb25zLlxuICAvLyBJZiB3ZSBhcmUgbm90IGFsbG93aW5nIHRoZXNlIHRhZ3MsIHdlIHNob3VsZCBkcm9wIHRoZWlyIGNvbnRlbnQgdG9vLlxuICAvLyBGb3Igb3RoZXIgdGFncyB5b3Ugd291bGQgZHJvcCB0aGUgdGFnIGJ1dCBrZWVwIGl0cyBjb250ZW50LlxuICBjb25zdCBub25UZXh0VGFnc0FycmF5ID0gb3B0aW9ucy5ub25UZXh0VGFncyB8fCBbXG4gICAgJ3NjcmlwdCcsXG4gICAgJ3N0eWxlJyxcbiAgICAndGV4dGFyZWEnLFxuICAgICdvcHRpb24nXG4gIF07XG4gIGxldCBhbGxvd2VkQXR0cmlidXRlc01hcDtcbiAgbGV0IGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcDtcbiAgaWYgKG9wdGlvbnMuYWxsb3dlZEF0dHJpYnV0ZXMpIHtcbiAgICBhbGxvd2VkQXR0cmlidXRlc01hcCA9IHt9O1xuICAgIGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcCA9IHt9O1xuICAgIGVhY2gob3B0aW9ucy5hbGxvd2VkQXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cmlidXRlcywgdGFnKSB7XG4gICAgICBhbGxvd2VkQXR0cmlidXRlc01hcFt0YWddID0gW107XG4gICAgICBjb25zdCBnbG9iUmVnZXggPSBbXTtcbiAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnICYmIG9iai5pbmRleE9mKCcqJykgPj0gMCkge1xuICAgICAgICAgIGdsb2JSZWdleC5wdXNoKGVzY2FwZVN0cmluZ1JlZ2V4cChvYmopLnJlcGxhY2UoL1xcXFxcXCovZywgJy4qJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzTWFwW3RhZ10ucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChnbG9iUmVnZXgubGVuZ3RoKSB7XG4gICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcFt0YWddID0gbmV3IFJlZ0V4cCgnXignICsgZ2xvYlJlZ2V4LmpvaW4oJ3wnKSArICcpJCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGFsbG93ZWRDbGFzc2VzTWFwID0ge307XG4gIGNvbnN0IGFsbG93ZWRDbGFzc2VzR2xvYk1hcCA9IHt9O1xuICBjb25zdCBhbGxvd2VkQ2xhc3Nlc1JlZ2V4TWFwID0ge307XG4gIGVhY2gob3B0aW9ucy5hbGxvd2VkQ2xhc3NlcywgZnVuY3Rpb24oY2xhc3NlcywgdGFnKSB7XG4gICAgLy8gSW1wbGljaXRseSBhbGxvd3MgdGhlIGNsYXNzIGF0dHJpYnV0ZVxuICAgIGlmIChhbGxvd2VkQXR0cmlidXRlc01hcCkge1xuICAgICAgaWYgKCFoYXMoYWxsb3dlZEF0dHJpYnV0ZXNNYXAsIHRhZykpIHtcbiAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXNNYXBbdGFnXSA9IFtdO1xuICAgICAgfVxuICAgICAgYWxsb3dlZEF0dHJpYnV0ZXNNYXBbdGFnXS5wdXNoKCdjbGFzcycpO1xuICAgIH1cblxuICAgIGFsbG93ZWRDbGFzc2VzTWFwW3RhZ10gPSBjbGFzc2VzO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NlcykpIHtcbiAgICAgIGNvbnN0IGdsb2JSZWdleCA9IFtdO1xuICAgICAgYWxsb3dlZENsYXNzZXNNYXBbdGFnXSA9IFtdO1xuICAgICAgYWxsb3dlZENsYXNzZXNSZWdleE1hcFt0YWddID0gW107XG4gICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyAmJiBvYmouaW5kZXhPZignKicpID49IDApIHtcbiAgICAgICAgICBnbG9iUmVnZXgucHVzaChlc2NhcGVTdHJpbmdSZWdleHAob2JqKS5yZXBsYWNlKC9cXFxcXFwqL2csICcuKicpKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICBhbGxvd2VkQ2xhc3Nlc1JlZ2V4TWFwW3RhZ10ucHVzaChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbG93ZWRDbGFzc2VzTWFwW3RhZ10ucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChnbG9iUmVnZXgubGVuZ3RoKSB7XG4gICAgICAgIGFsbG93ZWRDbGFzc2VzR2xvYk1hcFt0YWddID0gbmV3IFJlZ0V4cCgnXignICsgZ2xvYlJlZ2V4LmpvaW4oJ3wnKSArICcpJCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdHJhbnNmb3JtVGFnc01hcCA9IHt9O1xuICBsZXQgdHJhbnNmb3JtVGFnc0FsbDtcbiAgZWFjaChvcHRpb25zLnRyYW5zZm9ybVRhZ3MsIGZ1bmN0aW9uKHRyYW5zZm9ybSwgdGFnKSB7XG4gICAgbGV0IHRyYW5zRnVuO1xuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cmFuc0Z1biA9IHRyYW5zZm9ybTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cmFuc0Z1biA9IHNhbml0aXplSHRtbC5zaW1wbGVUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJyonKSB7XG4gICAgICB0cmFuc2Zvcm1UYWdzQWxsID0gdHJhbnNGdW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybVRhZ3NNYXBbdGFnXSA9IHRyYW5zRnVuO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGRlcHRoO1xuICBsZXQgc3RhY2s7XG4gIGxldCBza2lwTWFwO1xuICBsZXQgdHJhbnNmb3JtTWFwO1xuICBsZXQgc2tpcFRleHQ7XG4gIGxldCBza2lwVGV4dERlcHRoO1xuICBsZXQgYWRkZWRUZXh0ID0gZmFsc2U7XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCk7XG5cbiAgY29uc3QgcGFyc2VyID0gbmV3IGh0bWxwYXJzZXIuUGFyc2VyKHtcbiAgICBvbm9wZW50YWc6IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnMpIHtcbiAgICAgIC8vIElmIGBlbmZvcmNlSHRtbEJvdW5kYXJ5YCBpcyBgdHJ1ZWAgYW5kIHRoaXMgaGFzIGZvdW5kIHRoZSBvcGVuaW5nXG4gICAgICAvLyBgaHRtbGAgdGFnLCByZXNldCB0aGUgc3RhdGUuXG4gICAgICBpZiAob3B0aW9ucy5lbmZvcmNlSHRtbEJvdW5kYXJ5ICYmIG5hbWUgPT09ICdodG1sJykge1xuICAgICAgICBpbml0aWFsaXplU3RhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNraXBUZXh0KSB7XG4gICAgICAgIHNraXBUZXh0RGVwdGgrKztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgRnJhbWUobmFtZSwgYXR0cmlicyk7XG4gICAgICBzdGFjay5wdXNoKGZyYW1lKTtcblxuICAgICAgbGV0IHNraXAgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGhhc1RleHQgPSAhIWZyYW1lLnRleHQ7XG4gICAgICBsZXQgdHJhbnNmb3JtZWRUYWc7XG4gICAgICBpZiAoaGFzKHRyYW5zZm9ybVRhZ3NNYXAsIG5hbWUpKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkVGFnID0gdHJhbnNmb3JtVGFnc01hcFtuYW1lXShuYW1lLCBhdHRyaWJzKTtcblxuICAgICAgICBmcmFtZS5hdHRyaWJzID0gYXR0cmlicyA9IHRyYW5zZm9ybWVkVGFnLmF0dHJpYnM7XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkVGFnLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZyYW1lLmlubmVyVGV4dCA9IHRyYW5zZm9ybWVkVGFnLnRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSAhPT0gdHJhbnNmb3JtZWRUYWcudGFnTmFtZSkge1xuICAgICAgICAgIGZyYW1lLm5hbWUgPSBuYW1lID0gdHJhbnNmb3JtZWRUYWcudGFnTmFtZTtcbiAgICAgICAgICB0cmFuc2Zvcm1NYXBbZGVwdGhdID0gdHJhbnNmb3JtZWRUYWcudGFnTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybVRhZ3NBbGwpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRUYWcgPSB0cmFuc2Zvcm1UYWdzQWxsKG5hbWUsIGF0dHJpYnMpO1xuXG4gICAgICAgIGZyYW1lLmF0dHJpYnMgPSBhdHRyaWJzID0gdHJhbnNmb3JtZWRUYWcuYXR0cmlicztcbiAgICAgICAgaWYgKG5hbWUgIT09IHRyYW5zZm9ybWVkVGFnLnRhZ05hbWUpIHtcbiAgICAgICAgICBmcmFtZS5uYW1lID0gbmFtZSA9IHRyYW5zZm9ybWVkVGFnLnRhZ05hbWU7XG4gICAgICAgICAgdHJhbnNmb3JtTWFwW2RlcHRoXSA9IHRyYW5zZm9ybWVkVGFnLnRhZ05hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0YWdBbGxvd2VkKG5hbWUpIHx8IChvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ3JlY3Vyc2l2ZUVzY2FwZScgJiYgIWlzRW1wdHlPYmplY3Qoc2tpcE1hcCkpIHx8IChvcHRpb25zLm5lc3RpbmdMaW1pdCAhPSBudWxsICYmIGRlcHRoID49IG9wdGlvbnMubmVzdGluZ0xpbWl0KSkge1xuICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgICAgc2tpcE1hcFtkZXB0aF0gPSB0cnVlO1xuICAgICAgICBpZiAob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGUgPT09ICdkaXNjYXJkJyB8fCBvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ2NvbXBsZXRlbHlEaXNjYXJkJykge1xuICAgICAgICAgIGlmIChub25UZXh0VGFnc0FycmF5LmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBza2lwVGV4dCA9IHRydWU7XG4gICAgICAgICAgICBza2lwVGV4dERlcHRoID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2tpcE1hcFtkZXB0aF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZGVwdGgrKztcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ2Rpc2NhcmQnIHx8IG9wdGlvbnMuZGlzYWxsb3dlZFRhZ3NNb2RlID09PSAnY29tcGxldGVseURpc2NhcmQnKSB7XG4gICAgICAgICAgLy8gV2Ugd2FudCB0aGUgY29udGVudHMgYnV0IG5vdCB0aGlzIHRhZ1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnPCcgKyBuYW1lO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dlZFNjcmlwdEhvc3RuYW1lcyB8fCBvcHRpb25zLmFsbG93ZWRTY3JpcHREb21haW5zKSB7XG4gICAgICAgICAgZnJhbWUuaW5uZXJUZXh0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlc01hcCB8fCBoYXMoYWxsb3dlZEF0dHJpYnV0ZXNNYXAsIG5hbWUpIHx8IGFsbG93ZWRBdHRyaWJ1dGVzTWFwWycqJ10pIHtcbiAgICAgICAgZWFjaChhdHRyaWJzLCBmdW5jdGlvbih2YWx1ZSwgYSkge1xuICAgICAgICAgIGlmICghVkFMSURfSFRNTF9BVFRSSUJVVEVfTkFNRS50ZXN0KGEpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHBhcnQgb2YgYW4gYXR0cmlidXRlIG5hbWUgaW4gdGhlIG91dHB1dCBmcm9tIGJlaW5nXG4gICAgICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyB0aGUgZW5kIG9mIGFuIGF0dHJpYnV0ZSwgb3IgZW5kIG9mIGEgdGFnLlxuICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBlbXB0eSwgY2hlY2sgaWYgdGhlIGF0dHJpYnV0ZSBpcyBpbiB0aGUgYWxsb3dlZEVtcHR5QXR0cmlidXRlcyBhcnJheS5cbiAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgaW4gdGhlIGFsbG93ZWRFbXB0eUF0dHJpYnV0ZXMgYXJyYXksIGFuZCBpdCBpcyBhIGtub3duIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSwgZGVsZXRlIGl0XG4gICAgICAgICAgLy8gTGlzdCB0YWtlbiBmcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNhdHRyaWJ1dGVzLTNcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnICYmICghb3B0aW9ucy5hbGxvd2VkRW1wdHlBdHRyaWJ1dGVzLmluY2x1ZGVzKGEpKSAmJlxuICAgICAgICAgICAgKG9wdGlvbnMubm9uQm9vbGVhbkF0dHJpYnV0ZXMuaW5jbHVkZXMoYSkgfHwgb3B0aW9ucy5ub25Cb29sZWFuQXR0cmlidXRlcy5pbmNsdWRlcygnKicpKSkge1xuICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNoZWNrIGFsbG93ZWRBdHRyaWJ1dGVzTWFwIGZvciB0aGUgZWxlbWVudCBhbmQgYXR0cmlidXRlIGFuZCBtb2RpZnkgdGhlIHZhbHVlXG4gICAgICAgICAgLy8gYXMgbmVjZXNzYXJ5IGlmIHRoZXJlIGFyZSBzcGVjaWZpYyB2YWx1ZXMgZGVmaW5lZC5cbiAgICAgICAgICBsZXQgcGFzc2VkQWxsb3dlZEF0dHJpYnV0ZXNNYXBDaGVjayA9IGZhbHNlO1xuICAgICAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZXNNYXAgfHxcbiAgICAgICAgICAgIChoYXMoYWxsb3dlZEF0dHJpYnV0ZXNNYXAsIG5hbWUpICYmIGFsbG93ZWRBdHRyaWJ1dGVzTWFwW25hbWVdLmluZGV4T2YoYSkgIT09IC0xKSB8fFxuICAgICAgICAgICAgKGFsbG93ZWRBdHRyaWJ1dGVzTWFwWycqJ10gJiYgYWxsb3dlZEF0dHJpYnV0ZXNNYXBbJyonXS5pbmRleE9mKGEpICE9PSAtMSkgfHxcbiAgICAgICAgICAgIChoYXMoYWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwLCBuYW1lKSAmJiBhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXBbbmFtZV0udGVzdChhKSkgfHxcbiAgICAgICAgICAgIChhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXBbJyonXSAmJiBhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXBbJyonXS50ZXN0KGEpKSkge1xuICAgICAgICAgICAgcGFzc2VkQWxsb3dlZEF0dHJpYnV0ZXNNYXBDaGVjayA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbGxvd2VkQXR0cmlidXRlc01hcCAmJiBhbGxvd2VkQXR0cmlidXRlc01hcFtuYW1lXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBvIG9mIGFsbG93ZWRBdHRyaWJ1dGVzTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KG8pICYmIG8ubmFtZSAmJiAoby5uYW1lID09PSBhKSkge1xuICAgICAgICAgICAgICAgIHBhc3NlZEFsbG93ZWRBdHRyaWJ1dGVzTWFwQ2hlY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChvLm11bHRpcGxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAvLyB2ZXJpZnkgdGhlIHZhbHVlcyB0aGF0IGFyZSBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICBjb25zdCBzcGxpdFN0ckFycmF5ID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBzcGxpdFN0ckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnZhbHVlcy5pbmRleE9mKHMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gcztcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgKz0gJyAnICsgcztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG8udmFsdWVzLmluZGV4T2YodmFsdWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIHZlcmlmaWVkIGFuIGFsbG93ZWQgdmFsdWUgbWF0Y2hlcyB0aGUgZW50aXJlIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFzc2VkQWxsb3dlZEF0dHJpYnV0ZXNNYXBDaGVjaykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dlZFNjaGVtZXNBcHBsaWVkVG9BdHRyaWJ1dGVzLmluZGV4T2YoYSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGlmIChuYXVnaHR5SHJlZihuYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZnJhbWUuYXR0cmlic1thXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzY3JpcHQnICYmIGEgPT09ICdzcmMnKSB7XG5cbiAgICAgICAgICAgICAgbGV0IGFsbG93ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VVcmwodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dlZFNjcmlwdEhvc3RuYW1lcyB8fCBvcHRpb25zLmFsbG93ZWRTY3JpcHREb21haW5zKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkSG9zdG5hbWUgPSAob3B0aW9ucy5hbGxvd2VkU2NyaXB0SG9zdG5hbWVzIHx8IFtdKS5maW5kKGZ1bmN0aW9uIChob3N0bmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG9zdG5hbWUgPT09IHBhcnNlZC51cmwuaG9zdG5hbWU7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWREb21haW4gPSAob3B0aW9ucy5hbGxvd2VkU2NyaXB0RG9tYWlucyB8fCBbXSkuZmluZChmdW5jdGlvbihkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC51cmwuaG9zdG5hbWUgPT09IGRvbWFpbiB8fCBwYXJzZWQudXJsLmhvc3RuYW1lLmVuZHNXaXRoKGAuJHtkb21haW59YCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGFsbG93ZWQgPSBhbGxvd2VkSG9zdG5hbWUgfHwgYWxsb3dlZERvbWFpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZnJhbWUuYXR0cmlic1thXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpZnJhbWUnICYmIGEgPT09ICdzcmMnKSB7XG4gICAgICAgICAgICAgIGxldCBhbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVVybCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLmlzUmVsYXRpdmVVcmwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUgb2YgYWxsb3dJZnJhbWVSZWxhdGl2ZVVybHMgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgLy8gdW5sZXNzIGFsbG93ZWRJZnJhbWVIb3N0bmFtZXMgb3IgYWxsb3dlZElmcmFtZURvbWFpbnMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICBhbGxvd2VkID0gaGFzKG9wdGlvbnMsICdhbGxvd0lmcmFtZVJlbGF0aXZlVXJscycpXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5hbGxvd0lmcmFtZVJlbGF0aXZlVXJsc1xuICAgICAgICAgICAgICAgICAgICA6ICghb3B0aW9ucy5hbGxvd2VkSWZyYW1lSG9zdG5hbWVzICYmICFvcHRpb25zLmFsbG93ZWRJZnJhbWVEb21haW5zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dlZElmcmFtZUhvc3RuYW1lcyB8fCBvcHRpb25zLmFsbG93ZWRJZnJhbWVEb21haW5zKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkSG9zdG5hbWUgPSAob3B0aW9ucy5hbGxvd2VkSWZyYW1lSG9zdG5hbWVzIHx8IFtdKS5maW5kKGZ1bmN0aW9uIChob3N0bmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG9zdG5hbWUgPT09IHBhcnNlZC51cmwuaG9zdG5hbWU7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWREb21haW4gPSAob3B0aW9ucy5hbGxvd2VkSWZyYW1lRG9tYWlucyB8fCBbXSkuZmluZChmdW5jdGlvbihkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC51cmwuaG9zdG5hbWUgPT09IGRvbWFpbiB8fCBwYXJzZWQudXJsLmhvc3RuYW1lLmVuZHNXaXRoKGAuJHtkb21haW59YCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGFsbG93ZWQgPSBhbGxvd2VkSG9zdG5hbWUgfHwgYWxsb3dlZERvbWFpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBVbnBhcnNlYWJsZSBpZnJhbWUgc3JjXG4gICAgICAgICAgICAgICAgYWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEgPT09ICdzcmNzZXQnKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZCA9IHBhcnNlU3Jjc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBwYXJzZWQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5hdWdodHlIcmVmKCdzcmNzZXQnLCB2YWx1ZS51cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmV2aWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IGZpbHRlcihwYXJzZWQsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhdi5ldmlsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyaW5naWZ5U3Jjc2V0KGZpbHRlcihwYXJzZWQsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF2LmV2aWw7XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICBmcmFtZS5hdHRyaWJzW2FdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5wYXJzZWFibGUgc3Jjc2V0XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkU3BlY2lmaWNDbGFzc2VzID0gYWxsb3dlZENsYXNzZXNNYXBbbmFtZV07XG4gICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRXaWxkY2FyZENsYXNzZXMgPSBhbGxvd2VkQ2xhc3Nlc01hcFsnKiddO1xuICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkU3BlY2lmaWNDbGFzc2VzR2xvYiA9IGFsbG93ZWRDbGFzc2VzR2xvYk1hcFtuYW1lXTtcbiAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZFNwZWNpZmljQ2xhc3Nlc1JlZ2V4ID0gYWxsb3dlZENsYXNzZXNSZWdleE1hcFtuYW1lXTtcbiAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZFdpbGRjYXJkQ2xhc3Nlc0dsb2IgPSBhbGxvd2VkQ2xhc3Nlc0dsb2JNYXBbJyonXTtcbiAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZENsYXNzZXNHbG9icyA9IFtcbiAgICAgICAgICAgICAgICBhbGxvd2VkU3BlY2lmaWNDbGFzc2VzR2xvYixcbiAgICAgICAgICAgICAgICBhbGxvd2VkV2lsZGNhcmRDbGFzc2VzR2xvYlxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgLmNvbmNhdChhbGxvd2VkU3BlY2lmaWNDbGFzc2VzUmVnZXgpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChhbGxvd2VkU3BlY2lmaWNDbGFzc2VzICYmIGFsbG93ZWRXaWxkY2FyZENsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpbHRlckNsYXNzZXModmFsdWUsIGRlZXBtZXJnZShhbGxvd2VkU3BlY2lmaWNDbGFzc2VzLCBhbGxvd2VkV2lsZGNhcmRDbGFzc2VzKSwgYWxsb3dlZENsYXNzZXNHbG9icyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXJDbGFzc2VzKHZhbHVlLCBhbGxvd2VkU3BlY2lmaWNDbGFzc2VzIHx8IGFsbG93ZWRXaWxkY2FyZENsYXNzZXMsIGFsbG93ZWRDbGFzc2VzR2xvYnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZVN0eWxlQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhYnN0cmFjdFN5bnRheFRyZWUgPSBwb3N0Y3NzUGFyc2UobmFtZSArICcgeycgKyB2YWx1ZSArICd9JywgeyBtYXA6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRBU1QgPSBmaWx0ZXJDc3MoYWJzdHJhY3RTeW50YXhUcmVlLCBvcHRpb25zLmFsbG93ZWRTdHlsZXMpO1xuXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ2lmeVN0eWxlQXR0cmlidXRlcyhmaWx0ZXJlZEFTVCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgXCInICsgbmFtZSArICcgeycgKyB2YWx1ZSArICd9JyArICdcIiwgSWYgeW91XFwncmUgcnVubmluZyB0aGlzIGluIGEgYnJvd3Nlciwgd2UgcmVjb21tZW5kIHRvIGRpc2FibGUgc3R5bGUgcGFyc2luZzogb3B0aW9ucy5wYXJzZVN0eWxlQXR0cmlidXRlczogZmFsc2UsIHNpbmNlIHRoaXMgb25seSB3b3JrcyBpbiBhIG5vZGUgZW52aXJvbm1lbnQgZHVlIHRvIGEgcG9zdGNzcyBkZXBlbmRlbmN5LCBNb3JlIGluZm86IGh0dHBzOi8vZ2l0aHViLmNvbS9hcG9zdHJvcGhlY21zL3Nhbml0aXplLWh0bWwvaXNzdWVzLzU0NycpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dlZFN0eWxlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxsb3dlZFN0eWxlcyBvcHRpb24gY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBwYXJzZVN0eWxlQXR0cmlidXRlczogZmFsc2UuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnICcgKyBhO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gJz1cIicgKyBlc2NhcGVIdG1sKHZhbHVlLCB0cnVlKSArICdcIic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dlZEVtcHR5QXR0cmlidXRlcy5pbmNsdWRlcyhhKSkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gJz1cIlwiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNlbGZDbG9zaW5nLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdCArPSAnIC8+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSAnPic7XG4gICAgICAgIGlmIChmcmFtZS5pbm5lclRleHQgJiYgIWhhc1RleHQgJiYgIW9wdGlvbnMudGV4dEZpbHRlcikge1xuICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVIdG1sKGZyYW1lLmlubmVyVGV4dCk7XG4gICAgICAgICAgYWRkZWRUZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgcmVzdWx0ID0gdGVtcFJlc3VsdCArIGVzY2FwZUh0bWwocmVzdWx0KTtcbiAgICAgICAgdGVtcFJlc3VsdCA9ICcnO1xuICAgICAgfVxuICAgIH0sXG4gICAgb250ZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICBpZiAoc2tpcFRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFzdEZyYW1lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBsZXQgdGFnO1xuXG4gICAgICBpZiAobGFzdEZyYW1lKSB7XG4gICAgICAgIHRhZyA9IGxhc3RGcmFtZS50YWc7XG4gICAgICAgIC8vIElmIGlubmVyIHRleHQgd2FzIHNldCBieSB0cmFuc2Zvcm0gZnVuY3Rpb24gdGhlbiBsZXQncyB1c2UgaXRcbiAgICAgICAgdGV4dCA9IGxhc3RGcmFtZS5pbm5lclRleHQgIT09IHVuZGVmaW5lZCA/IGxhc3RGcmFtZS5pbm5lclRleHQgOiB0ZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGUgPT09ICdjb21wbGV0ZWx5RGlzY2FyZCcgJiYgIXRhZ0FsbG93ZWQodGFnKSkge1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKChvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ2Rpc2NhcmQnIHx8IG9wdGlvbnMuZGlzYWxsb3dlZFRhZ3NNb2RlID09PSAnY29tcGxldGVseURpc2NhcmQnKSAmJiAoKHRhZyA9PT0gJ3NjcmlwdCcpIHx8ICh0YWcgPT09ICdzdHlsZScpKSkge1xuICAgICAgICAvLyBodG1scGFyc2VyMiBnaXZlcyB1cyB0aGVzZSBhcy1pcy4gRXNjYXBpbmcgdGhlbSBydWlucyB0aGUgY29udGVudC4gQWxsb3dpbmdcbiAgICAgICAgLy8gc2NyaXB0IHRhZ3MgaXMsIGJ5IGRlZmluaXRpb24sIGdhbWUgb3ZlciBmb3IgWFNTIHByb3RlY3Rpb24sIHNvIGlmIHRoYXQnc1xuICAgICAgICAvLyB5b3VyIGNvbmNlcm4sIGRvbid0IGFsbG93IHRoZW0uIFRoZSBzYW1lIGlzIGVzc2VudGlhbGx5IHRydWUgZm9yIHN0eWxlIHRhZ3NcbiAgICAgICAgLy8gd2hpY2ggaGF2ZSB0aGVpciBvd24gY29sbGVjdGlvbiBvZiBYU1MgdmVjdG9ycy5cbiAgICAgICAgcmVzdWx0ICs9IHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlc2NhcGVkID0gZXNjYXBlSHRtbCh0ZXh0LCBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRleHRGaWx0ZXIgJiYgIWFkZGVkVGV4dCkge1xuICAgICAgICAgIHJlc3VsdCArPSBvcHRpb25zLnRleHRGaWx0ZXIoZXNjYXBlZCwgdGFnKTtcbiAgICAgICAgfSBlbHNlIGlmICghYWRkZWRUZXh0KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgZnJhbWUudGV4dCArPSB0ZXh0O1xuICAgICAgfVxuICAgIH0sXG4gICAgb25jbG9zZXRhZzogZnVuY3Rpb24obmFtZSwgaXNJbXBsaWVkKSB7XG5cbiAgICAgIGlmIChza2lwVGV4dCkge1xuICAgICAgICBza2lwVGV4dERlcHRoLS07XG4gICAgICAgIGlmICghc2tpcFRleHREZXB0aCkge1xuICAgICAgICAgIHNraXBUZXh0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZyYW1lID0gc3RhY2sucG9wKCk7XG4gICAgICBpZiAoIWZyYW1lKSB7XG4gICAgICAgIC8vIERvIG5vdCBjcmFzaCBvbiBiYWQgbWFya3VwXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYW1lLnRhZyAhPT0gbmFtZSkge1xuICAgICAgICAvLyBBbm90aGVyIGNhc2Ugb2YgYmFkIG1hcmt1cC5cbiAgICAgICAgLy8gUHVzaCB0byBzdGFjaywgc28gdGhhdCBpdCB3aWxsIGJlIHVzZWQgaW4gZnV0dXJlIGNsb3NpbmcgdGFncy5cbiAgICAgICAgc3RhY2sucHVzaChmcmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2tpcFRleHQgPSBvcHRpb25zLmVuZm9yY2VIdG1sQm91bmRhcnkgPyBuYW1lID09PSAnaHRtbCcgOiBmYWxzZTtcbiAgICAgIGRlcHRoLS07XG4gICAgICBjb25zdCBza2lwID0gc2tpcE1hcFtkZXB0aF07XG4gICAgICBpZiAoc2tpcCkge1xuICAgICAgICBkZWxldGUgc2tpcE1hcFtkZXB0aF07XG4gICAgICAgIGlmIChvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ2Rpc2NhcmQnIHx8IG9wdGlvbnMuZGlzYWxsb3dlZFRhZ3NNb2RlID09PSAnY29tcGxldGVseURpc2NhcmQnKSB7XG4gICAgICAgICAgZnJhbWUudXBkYXRlUGFyZW50Tm9kZVRleHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGVtcFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm1NYXBbZGVwdGhdKSB7XG4gICAgICAgIG5hbWUgPSB0cmFuc2Zvcm1NYXBbZGVwdGhdO1xuICAgICAgICBkZWxldGUgdHJhbnNmb3JtTWFwW2RlcHRoXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZXhjbHVzaXZlRmlsdGVyICYmIG9wdGlvbnMuZXhjbHVzaXZlRmlsdGVyKGZyYW1lKSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyKDAsIGZyYW1lLnRhZ1Bvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmcmFtZS51cGRhdGVQYXJlbnROb2RlTWVkaWFDaGlsZHJlbigpO1xuICAgICAgZnJhbWUudXBkYXRlUGFyZW50Tm9kZVRleHQoKTtcblxuICAgICAgaWYgKFxuICAgICAgICAvLyBBbHJlYWR5IG91dHB1dCAvPlxuICAgICAgICBvcHRpb25zLnNlbGZDbG9zaW5nLmluZGV4T2YobmFtZSkgIT09IC0xIHx8XG4gICAgICAgIC8vIEVzY2FwZWQgdGFnLCBjbG9zaW5nIHRhZyBpcyBpbXBsaWVkXG4gICAgICAgIChpc0ltcGxpZWQgJiYgIXRhZ0FsbG93ZWQobmFtZSkgJiYgWyAnZXNjYXBlJywgJ3JlY3Vyc2l2ZUVzY2FwZScgXS5pbmRleE9mKG9wdGlvbnMuZGlzYWxsb3dlZFRhZ3NNb2RlKSA+PSAwKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdGVtcFJlc3VsdDtcbiAgICAgICAgICB0ZW1wUmVzdWx0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gJzwvJyArIG5hbWUgKyAnPic7XG4gICAgICBpZiAoc2tpcCkge1xuICAgICAgICByZXN1bHQgPSB0ZW1wUmVzdWx0ICsgZXNjYXBlSHRtbChyZXN1bHQpO1xuICAgICAgICB0ZW1wUmVzdWx0ID0gJyc7XG4gICAgICB9XG4gICAgICBhZGRlZFRleHQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIG9wdGlvbnMucGFyc2VyKTtcbiAgcGFyc2VyLndyaXRlKGh0bWwpO1xuICBwYXJzZXIuZW5kKCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxuICBmdW5jdGlvbiBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgcmVzdWx0ID0gJyc7XG4gICAgZGVwdGggPSAwO1xuICAgIHN0YWNrID0gW107XG4gICAgc2tpcE1hcCA9IHt9O1xuICAgIHRyYW5zZm9ybU1hcCA9IHt9O1xuICAgIHNraXBUZXh0ID0gZmFsc2U7XG4gICAgc2tpcFRleHREZXB0aCA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVIdG1sKHMsIHF1b3RlKSB7XG4gICAgaWYgKHR5cGVvZiAocykgIT09ICdzdHJpbmcnKSB7XG4gICAgICBzID0gcyArICcnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYXJzZXIuZGVjb2RlRW50aXRpZXMpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgICAgIGlmIChxdW90ZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IHRoaXMgaXMgaW5hZGVxdWF0ZSBiZWNhdXNlIGl0IHdpbGwgcGFzcyBgJjA7YC4gVGhpcyBhcHByb2FjaFxuICAgIC8vIHdpbGwgbm90IHdvcmssIGVhY2ggJiBtdXN0IGJlIGNvbnNpZGVyZWQgd2l0aCByZWdhcmQgdG8gd2hldGhlciBpdFxuICAgIC8vIGlzIGZvbGxvd2VkIGJ5IGEgMTAwJSBzeW50YWN0aWNhbGx5IHZhbGlkIGVudGl0eSBvciBub3QsIGFuZCBlc2NhcGVkXG4gICAgLy8gaWYgaXQgaXMgbm90LiBJZiB0aGlzIGJvdGhlcnMgeW91LCBkb24ndCBzZXQgcGFyc2VyLmRlY29kZUVudGl0aWVzXG4gICAgLy8gdG8gZmFsc2UuIChUaGUgZGVmYXVsdCBpcyB0cnVlLilcbiAgICBzID0gcy5yZXBsYWNlKC8mKD8hW2EtekEtWjAtOSNdezEsMjB9OykvZywgJyZhbXA7JykgLy8gTWF0Y2ggYW1wZXJzYW5kcyBub3QgcGFydCBvZiBleGlzdGluZyBIVE1MIGVudGl0eVxuICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgICBpZiAocXVvdGUpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICBmdW5jdGlvbiBuYXVnaHR5SHJlZihuYW1lLCBocmVmKSB7XG4gICAgLy8gQnJvd3NlcnMgaWdub3JlIGNoYXJhY3RlciBjb2RlcyBvZiAzMiAoc3BhY2UpIGFuZCBiZWxvdyBpbiBhIHN1cnByaXNpbmdcbiAgICAvLyBudW1iZXIgb2Ygc2l0dWF0aW9ucy4gU3RhcnQgcmVhZGluZyBoZXJlOlxuICAgIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0I0VtYmVkZGVkX3RhYlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgaHJlZiA9IGhyZWYucmVwbGFjZSgvW1xceDAwLVxceDIwXSsvZywgJycpO1xuICAgIC8vIENsb2JiZXIgYW55IGNvbW1lbnRzIGluIFVSTHMsIHdoaWNoIHRoZSBicm93c2VyIG1pZ2h0XG4gICAgLy8gaW50ZXJwcmV0IGluc2lkZSBhbiBYTUwgZGF0YSBpc2xhbmQsIGFsbG93aW5nXG4gICAgLy8gYSBqYXZhc2NyaXB0OiBVUkwgdG8gYmUgc251Y2sgdGhyb3VnaFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBmaXJzdEluZGV4ID0gaHJlZi5pbmRleE9mKCc8IS0tJyk7XG4gICAgICBpZiAoZmlyc3RJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBocmVmLmluZGV4T2YoJy0tPicsIGZpcnN0SW5kZXggKyA0KTtcbiAgICAgIGlmIChsYXN0SW5kZXggPT09IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaHJlZiA9IGhyZWYuc3Vic3RyaW5nKDAsIGZpcnN0SW5kZXgpICsgaHJlZi5zdWJzdHJpbmcobGFzdEluZGV4ICsgMyk7XG4gICAgfVxuICAgIC8vIENhc2UgaW5zZW5zaXRpdmUgc28gd2UgZG9uJ3QgZ2V0IGZha2VkIG91dCBieSBKQVZBU0NSSVBUICMxXG4gICAgLy8gQWxsb3cgbW9yZSBjaGFyYWN0ZXJzIGFmdGVyIHRoZSBmaXJzdCBzbyB3ZSBkb24ndCBnZXQgZmFrZWRcbiAgICAvLyBvdXQgYnkgY2VydGFpbiBzY2hlbWVzIGJyb3dzZXJzIGFjY2VwdFxuICAgIGNvbnN0IG1hdGNoZXMgPSBocmVmLm1hdGNoKC9eKFthLXpBLVpdW2EtekEtWjAtOS5cXC0rXSopOi8pO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgLy8gUHJvdG9jb2wtcmVsYXRpdmUgVVJMIHN0YXJ0aW5nIHdpdGggYW55IGNvbWJpbmF0aW9uIG9mICcvJyBhbmQgJ1xcJ1xuICAgICAgaWYgKGhyZWYubWF0Y2goL15bL1xcXFxdezJ9LykpIHtcbiAgICAgICAgcmV0dXJuICFvcHRpb25zLmFsbG93UHJvdG9jb2xSZWxhdGl2ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTm8gc2NoZW1lXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChoYXMob3B0aW9ucy5hbGxvd2VkU2NoZW1lc0J5VGFnLCBuYW1lKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYWxsb3dlZFNjaGVtZXNCeVRhZ1tuYW1lXS5pbmRleE9mKHNjaGVtZSkgPT09IC0xO1xuICAgIH1cblxuICAgIHJldHVybiAhb3B0aW9ucy5hbGxvd2VkU2NoZW1lcyB8fCBvcHRpb25zLmFsbG93ZWRTY2hlbWVzLmluZGV4T2Yoc2NoZW1lKSA9PT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVVybCh2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXihcXHcrOik/XFxzKltcXFxcL11cXHMqW1xcXFwvXS8sICckMS8vJyk7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ3JlbGF0aXZlOicpKSB7XG4gICAgICAvLyBBbiBhdHRlbXB0IHRvIGV4cGxvaXQgb3VyIHdvcmthcm91bmQgZm9yIGJhc2UgVVJMcyBiZWluZ1xuICAgICAgLy8gbWFuZGF0b3J5IGZvciByZWxhdGl2ZSBVUkwgdmFsaWRhdGlvbiBpbiB0aGUgV0hBVFdHXG4gICAgICAvLyBVUkwgcGFyc2VyLCByZWplY3QgaXRcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVsYXRpdmU6IGV4cGxvaXQgYXR0ZW1wdCcpO1xuICAgIH1cbiAgICAvLyBuYXVnaHR5SHJlZiBpcyBpbiBjaGFyZ2Ugb2Ygd2hldGhlciBwcm90b2NvbCByZWxhdGl2ZSBVUkxzXG4gICAgLy8gYXJlIGNvb2wuIEhlcmUgd2UgYXJlIGNvbmNlcm5lZCBqdXN0IHdpdGggYWxsb3dlZCBob3N0bmFtZXMgYW5kXG4gICAgLy8gd2hldGhlciB0byBhbGxvdyByZWxhdGl2ZSBVUkxzLlxuICAgIC8vXG4gICAgLy8gQnVpbGQgYSBwbGFjZWhvbGRlciBcImJhc2UgVVJMXCIgYWdhaW5zdCB3aGljaCBhbnkgcmVhc29uYWJsZVxuICAgIC8vIHJlbGF0aXZlIFVSTCBtYXkgYmUgcGFyc2VkIHN1Y2Nlc3NmdWxseVxuICAgIGxldCBiYXNlID0gJ3JlbGF0aXZlOi8vcmVsYXRpdmUtc2l0ZSc7XG4gICAgZm9yIChsZXQgaSA9IDA7IChpIDwgMTAwKTsgaSsrKSB7XG4gICAgICBiYXNlICs9IGAvJHtpfWA7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkID0gbmV3IFVSTCh2YWx1ZSwgYmFzZSk7XG5cbiAgICBjb25zdCBpc1JlbGF0aXZlVXJsID0gcGFyc2VkICYmIHBhcnNlZC5ob3N0bmFtZSA9PT0gJ3JlbGF0aXZlLXNpdGUnICYmIHBhcnNlZC5wcm90b2NvbCA9PT0gJ3JlbGF0aXZlOic7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzUmVsYXRpdmVVcmwsXG4gICAgICB1cmw6IHBhcnNlZFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEZpbHRlcnMgdXNlciBpbnB1dCBjc3MgcHJvcGVydGllcyBieSBhbGxvd2xpc3RlZCByZWdleCBhdHRyaWJ1dGVzLlxuICAgKiBNb2RpZmllcyB0aGUgYWJzdHJhY3RTeW50YXhUcmVlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGFic3RyYWN0U3ludGF4VHJlZSAgLSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgQ1NTIGF0dHJpYnV0ZXMuXG4gICAqIEBwcm9wZXJ0eSB7YXJyYXlbRGVjbGFyYXRpb25dfSBhYnN0cmFjdFN5bnRheFRyZWUubm9kZXNbMF0gLSBFYWNoIG9iamVjdCBjb2ludGFpbnMgcHJvcCBhbmQgdmFsdWUga2V5LCBpLmUgeyBwcm9wOiAnY29sb3InLCB2YWx1ZTogJ3JlZCcgfS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGFsbG93ZWRTdHlsZXMgICAgICAgLSBLZXlzIGFyZSBwcm9wZXJ0aWVzIChpLmUgY29sb3IpLCB2YWx1ZSBpcyBsaXN0IG9mIHBlcm1pdHRlZCByZWdleCBydWxlcyAoaS5lIC9ncmVlbi9pKS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgLSBUaGUgbW9kaWZpZWQgdHJlZS5cbiAgICovXG4gIGZ1bmN0aW9uIGZpbHRlckNzcyhhYnN0cmFjdFN5bnRheFRyZWUsIGFsbG93ZWRTdHlsZXMpIHtcbiAgICBpZiAoIWFsbG93ZWRTdHlsZXMpIHtcbiAgICAgIHJldHVybiBhYnN0cmFjdFN5bnRheFRyZWU7XG4gICAgfVxuXG4gICAgY29uc3QgYXN0UnVsZXMgPSBhYnN0cmFjdFN5bnRheFRyZWUubm9kZXNbMF07XG4gICAgbGV0IHNlbGVjdGVkUnVsZTtcblxuICAgIC8vIE1lcmdlIGdsb2JhbCBhbmQgdGFnLXNwZWNpZmljIHN0eWxlcyBpbnRvIG5ldyBBU1QuXG4gICAgaWYgKGFsbG93ZWRTdHlsZXNbYXN0UnVsZXMuc2VsZWN0b3JdICYmIGFsbG93ZWRTdHlsZXNbJyonXSkge1xuICAgICAgc2VsZWN0ZWRSdWxlID0gZGVlcG1lcmdlKFxuICAgICAgICBhbGxvd2VkU3R5bGVzW2FzdFJ1bGVzLnNlbGVjdG9yXSxcbiAgICAgICAgYWxsb3dlZFN0eWxlc1snKiddXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RlZFJ1bGUgPSBhbGxvd2VkU3R5bGVzW2FzdFJ1bGVzLnNlbGVjdG9yXSB8fCBhbGxvd2VkU3R5bGVzWycqJ107XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkUnVsZSkge1xuICAgICAgYWJzdHJhY3RTeW50YXhUcmVlLm5vZGVzWzBdLm5vZGVzID0gYXN0UnVsZXMubm9kZXMucmVkdWNlKGZpbHRlckRlY2xhcmF0aW9ucyhzZWxlY3RlZFJ1bGUpLCBbXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFic3RyYWN0U3ludGF4VHJlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgc3R5bGUgYXR0cmlidXRlcyBmcm9tIGFuIEFic3RyYWN0U3ludGF4VHJlZSBhbmQgZm9ybWF0cyB0aG9zZVxuICAgKiB2YWx1ZXMgaW4gdGhlIGlubGluZSBzdHlsZSBhdHRyaWJ1dGUgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtBYnN0cmFjdFN5bnRheFRyZWV9IGZpbHRlcmVkQVNUXG4gICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgLSBFeGFtcGxlOiBcImNvbG9yOnllbGxvdzt0ZXh0LWFsaWduOmNlbnRlciAhaW1wb3J0YW50O2ZvbnQtZmFtaWx5OmhlbHZldGljYTtcIlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGVBdHRyaWJ1dGVzKGZpbHRlcmVkQVNUKSB7XG4gICAgcmV0dXJuIGZpbHRlcmVkQVNULm5vZGVzWzBdLm5vZGVzXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uKGV4dHJhY3RlZEF0dHJpYnV0ZXMsIGF0dHJPYmplY3QpIHtcbiAgICAgICAgZXh0cmFjdGVkQXR0cmlidXRlcy5wdXNoKFxuICAgICAgICAgIGAke2F0dHJPYmplY3QucHJvcH06JHthdHRyT2JqZWN0LnZhbHVlfSR7YXR0ck9iamVjdC5pbXBvcnRhbnQgPyAnICFpbXBvcnRhbnQnIDogJyd9YFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZXh0cmFjdGVkQXR0cmlidXRlcztcbiAgICAgIH0sIFtdKVxuICAgICAgLmpvaW4oJzsnKTtcbiAgfVxuXG4gIC8qKlxuICAgICogRmlsdGVycyB0aGUgZXhpc3RpbmcgYXR0cmlidXRlcyBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LiBEaXNjYXJkcyBhbnkgYXR0cmlidXRlc1xuICAgICogd2hpY2ggZG9uJ3QgbWF0Y2ggdGhlIGFsbG93bGlzdC5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtvYmplY3R9IHNlbGVjdGVkUnVsZSAgICAgICAgICAgICAtIEV4YW1wbGU6IHsgY29sb3I6IHJlZCwgZm9udC1mYW1pbHk6IGhlbHZldGljYSB9XG4gICAgKiBAcGFyYW0gIHthcnJheX0gYWxsb3dlZERlY2xhcmF0aW9uc0xpc3QgICAtIExpc3Qgb2YgZGVjbGFyYXRpb25zIHdoaWNoIHBhc3MgdGhlIGFsbG93bGlzdC5cbiAgICAqIEBwYXJhbSAge29iamVjdH0gYXR0cmlidXRlT2JqZWN0ICAgICAgICAgIC0gT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBjc3MgcHJvcGVydHkuXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gYXR0cmlidXRlT2JqZWN0LnR5cGUgICAtIFR5cGljYWxseSAnZGVjbGFyYXRpb24nLlxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHJpYnV0ZU9iamVjdC5wcm9wICAgLSBUaGUgQ1NTIHByb3BlcnR5LCBpLmUgJ2NvbG9yJy5cbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyaWJ1dGVPYmplY3QudmFsdWUgIC0gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgdG8gdGhlIGNzcyBwcm9wZXJ0eSwgaS5lICdyZWQnLlxuICAgICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICAgICAgICAgICAgICAgLSBXaGVuIHVzZWQgaW4gQXJyYXkucmVkdWNlLCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBEZWNsYXJhdGlvbiBvYmplY3RzXG4gICAgKi9cbiAgZnVuY3Rpb24gZmlsdGVyRGVjbGFyYXRpb25zKHNlbGVjdGVkUnVsZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWxsb3dlZERlY2xhcmF0aW9uc0xpc3QsIGF0dHJpYnV0ZU9iamVjdCkge1xuICAgICAgLy8gSWYgdGhpcyBwcm9wZXJ0eSBpcyBhbGxvd2xpc3RlZC4uLlxuICAgICAgaWYgKGhhcyhzZWxlY3RlZFJ1bGUsIGF0dHJpYnV0ZU9iamVjdC5wcm9wKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVzUmVnZXggPSBzZWxlY3RlZFJ1bGVbYXR0cmlidXRlT2JqZWN0LnByb3BdLnNvbWUoZnVuY3Rpb24ocmVndWxhckV4cHJlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gcmVndWxhckV4cHJlc3Npb24udGVzdChhdHRyaWJ1dGVPYmplY3QudmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlc1JlZ2V4KSB7XG4gICAgICAgICAgYWxsb3dlZERlY2xhcmF0aW9uc0xpc3QucHVzaChhdHRyaWJ1dGVPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsb3dlZERlY2xhcmF0aW9uc0xpc3Q7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckNsYXNzZXMoY2xhc3NlcywgYWxsb3dlZCwgYWxsb3dlZEdsb2JzKSB7XG4gICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAvLyBUaGUgY2xhc3MgYXR0cmlidXRlIGlzIGFsbG93ZWQgd2l0aG91dCBmaWx0ZXJpbmcgb24gdGhpcyB0YWdcbiAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH1cbiAgICBjbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgIHJldHVybiBjbGFzc2VzLmZpbHRlcihmdW5jdGlvbihjbHNzKSB7XG4gICAgICByZXR1cm4gYWxsb3dlZC5pbmRleE9mKGNsc3MpICE9PSAtMSB8fCBhbGxvd2VkR2xvYnMuc29tZShmdW5jdGlvbihnbG9iKSB7XG4gICAgICAgIHJldHVybiBnbG9iLnRlc3QoY2xzcyk7XG4gICAgICB9KTtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cbn1cblxuLy8gRGVmYXVsdHMgYXJlIGFjY2Vzc2libGUgdG8geW91IHNvIHRoYXQgeW91IGNhbiB1c2UgdGhlbSBhcyBhIHN0YXJ0aW5nIHBvaW50XG4vLyBwcm9ncmFtbWF0aWNhbGx5IGlmIHlvdSB3aXNoXG5cbmNvbnN0IGh0bWxQYXJzZXJEZWZhdWx0cyA9IHtcbiAgZGVjb2RlRW50aXRpZXM6IHRydWVcbn07XG5zYW5pdGl6ZUh0bWwuZGVmYXVsdHMgPSB7XG4gIGFsbG93ZWRUYWdzOiBbXG4gICAgLy8gU2VjdGlvbnMgZGVyaXZlZCBmcm9tIE1ETiBlbGVtZW50IGNhdGVnb3JpZXMgYW5kIGxpbWl0ZWQgdG8gdGhlIG1vcmVcbiAgICAvLyBiZW5pZ24gY2F0ZWdvcmllcy5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcbiAgICAvLyBDb250ZW50IHNlY3Rpb25pbmdcbiAgICAnYWRkcmVzcycsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Zvb3RlcicsICdoZWFkZXInLFxuICAgICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZ3JvdXAnLFxuICAgICdtYWluJywgJ25hdicsICdzZWN0aW9uJyxcbiAgICAvLyBUZXh0IGNvbnRlbnRcbiAgICAnYmxvY2txdW90ZScsICdkZCcsICdkaXYnLCAnZGwnLCAnZHQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLFxuICAgICdocicsICdsaScsICdtYWluJywgJ29sJywgJ3AnLCAncHJlJywgJ3VsJyxcbiAgICAvLyBJbmxpbmUgdGV4dCBzZW1hbnRpY3NcbiAgICAnYScsICdhYmJyJywgJ2InLCAnYmRpJywgJ2JkbycsICdicicsICdjaXRlJywgJ2NvZGUnLCAnZGF0YScsICdkZm4nLFxuICAgICdlbScsICdpJywgJ2tiZCcsICdtYXJrJywgJ3EnLFxuICAgICdyYicsICdycCcsICdydCcsICdydGMnLCAncnVieScsXG4gICAgJ3MnLCAnc2FtcCcsICdzbWFsbCcsICdzcGFuJywgJ3N0cm9uZycsICdzdWInLCAnc3VwJywgJ3RpbWUnLCAndScsICd2YXInLCAnd2JyJyxcbiAgICAvLyBUYWJsZSBjb250ZW50XG4gICAgJ2NhcHRpb24nLCAnY29sJywgJ2NvbGdyb3VwJywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3Rmb290JywgJ3RoJyxcbiAgICAndGhlYWQnLCAndHInXG4gIF0sXG4gIC8vIFRhZ3MgdGhhdCBjYW5ub3QgYmUgYm9vbGVhblxuICBub25Cb29sZWFuQXR0cmlidXRlczogW1xuICAgICdhYmJyJywgJ2FjY2VwdCcsICdhY2NlcHQtY2hhcnNldCcsICdhY2Nlc3NrZXknLCAnYWN0aW9uJyxcbiAgICAnYWxsb3cnLCAnYWx0JywgJ2FzJywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsXG4gICAgJ2Jsb2NraW5nJywgJ2NoYXJzZXQnLCAnY2l0ZScsICdjbGFzcycsICdjb2xvcicsICdjb2xzJyxcbiAgICAnY29sc3BhbicsICdjb250ZW50JywgJ2NvbnRlbnRlZGl0YWJsZScsICdjb29yZHMnLCAnY3Jvc3NvcmlnaW4nLFxuICAgICdkYXRhJywgJ2RhdGV0aW1lJywgJ2RlY29kaW5nJywgJ2RpcicsICdkaXJuYW1lJywgJ2Rvd25sb2FkJyxcbiAgICAnZHJhZ2dhYmxlJywgJ2VuY3R5cGUnLCAnZW50ZXJrZXloaW50JywgJ2ZldGNocHJpb3JpdHknLCAnZm9yJyxcbiAgICAnZm9ybScsICdmb3JtYWN0aW9uJywgJ2Zvcm1lbmN0eXBlJywgJ2Zvcm1tZXRob2QnLCAnZm9ybXRhcmdldCcsXG4gICAgJ2hlYWRlcnMnLCAnaGVpZ2h0JywgJ2hpZGRlbicsICdoaWdoJywgJ2hyZWYnLCAnaHJlZmxhbmcnLFxuICAgICdodHRwLWVxdWl2JywgJ2lkJywgJ2ltYWdlc2l6ZXMnLCAnaW1hZ2VzcmNzZXQnLCAnaW5wdXRtb2RlJyxcbiAgICAnaW50ZWdyaXR5JywgJ2lzJywgJ2l0ZW1pZCcsICdpdGVtcHJvcCcsICdpdGVtcmVmJywgJ2l0ZW10eXBlJyxcbiAgICAna2luZCcsICdsYWJlbCcsICdsYW5nJywgJ2xpc3QnLCAnbG9hZGluZycsICdsb3cnLCAnbWF4JyxcbiAgICAnbWF4bGVuZ3RoJywgJ21lZGlhJywgJ21ldGhvZCcsICdtaW4nLCAnbWlubGVuZ3RoJywgJ25hbWUnLFxuICAgICdub25jZScsICdvcHRpbXVtJywgJ3BhdHRlcm4nLCAncGluZycsICdwbGFjZWhvbGRlcicsICdwb3BvdmVyJyxcbiAgICAncG9wb3ZlcnRhcmdldCcsICdwb3BvdmVydGFyZ2V0YWN0aW9uJywgJ3Bvc3RlcicsICdwcmVsb2FkJyxcbiAgICAncmVmZXJyZXJwb2xpY3knLCAncmVsJywgJ3Jvd3MnLCAncm93c3BhbicsICdzYW5kYm94JywgJ3Njb3BlJyxcbiAgICAnc2hhcGUnLCAnc2l6ZScsICdzaXplcycsICdzbG90JywgJ3NwYW4nLCAnc3BlbGxjaGVjaycsICdzcmMnLFxuICAgICdzcmNkb2MnLCAnc3JjbGFuZycsICdzcmNzZXQnLCAnc3RhcnQnLCAnc3RlcCcsICdzdHlsZScsXG4gICAgJ3RhYmluZGV4JywgJ3RhcmdldCcsICd0aXRsZScsICd0cmFuc2xhdGUnLCAndHlwZScsICd1c2VtYXAnLFxuICAgICd2YWx1ZScsICd3aWR0aCcsICd3cmFwJyxcbiAgICAvLyBFdmVudCBoYW5kbGVyc1xuICAgICdvbmF1eGNsaWNrJywgJ29uYWZ0ZXJwcmludCcsICdvbmJlZm9yZW1hdGNoJywgJ29uYmVmb3JlcHJpbnQnLFxuICAgICdvbmJlZm9yZXVubG9hZCcsICdvbmJlZm9yZXRvZ2dsZScsICdvbmJsdXInLCAnb25jYW5jZWwnLFxuICAgICdvbmNhbnBsYXknLCAnb25jYW5wbGF5dGhyb3VnaCcsICdvbmNoYW5nZScsICdvbmNsaWNrJywgJ29uY2xvc2UnLFxuICAgICdvbmNvbnRleHRsb3N0JywgJ29uY29udGV4dG1lbnUnLCAnb25jb250ZXh0cmVzdG9yZWQnLCAnb25jb3B5JyxcbiAgICAnb25jdWVjaGFuZ2UnLCAnb25jdXQnLCAnb25kYmxjbGljaycsICdvbmRyYWcnLCAnb25kcmFnZW5kJyxcbiAgICAnb25kcmFnZW50ZXInLCAnb25kcmFnbGVhdmUnLCAnb25kcmFnb3ZlcicsICdvbmRyYWdzdGFydCcsXG4gICAgJ29uZHJvcCcsICdvbmR1cmF0aW9uY2hhbmdlJywgJ29uZW1wdGllZCcsICdvbmVuZGVkJyxcbiAgICAnb25lcnJvcicsICdvbmZvY3VzJywgJ29uZm9ybWRhdGEnLCAnb25oYXNoY2hhbmdlJywgJ29uaW5wdXQnLFxuICAgICdvbmludmFsaWQnLCAnb25rZXlkb3duJywgJ29ua2V5cHJlc3MnLCAnb25rZXl1cCcsXG4gICAgJ29ubGFuZ3VhZ2VjaGFuZ2UnLCAnb25sb2FkJywgJ29ubG9hZGVkZGF0YScsICdvbmxvYWRlZG1ldGFkYXRhJyxcbiAgICAnb25sb2Fkc3RhcnQnLCAnb25tZXNzYWdlJywgJ29ubWVzc2FnZWVycm9yJywgJ29ubW91c2Vkb3duJyxcbiAgICAnb25tb3VzZWVudGVyJywgJ29ubW91c2VsZWF2ZScsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JyxcbiAgICAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ29ub2ZmbGluZScsICdvbm9ubGluZScsICdvbnBhZ2VoaWRlJyxcbiAgICAnb25wYWdlc2hvdycsICdvbnBhc3RlJywgJ29ucGF1c2UnLCAnb25wbGF5JywgJ29ucGxheWluZycsXG4gICAgJ29ucG9wc3RhdGUnLCAnb25wcm9ncmVzcycsICdvbnJhdGVjaGFuZ2UnLCAnb25yZXNldCcsICdvbnJlc2l6ZScsXG4gICAgJ29ucmVqZWN0aW9uaGFuZGxlZCcsICdvbnNjcm9sbCcsICdvbnNjcm9sbGVuZCcsXG4gICAgJ29uc2VjdXJpdHlwb2xpY3l2aW9sYXRpb24nLCAnb25zZWVrZWQnLCAnb25zZWVraW5nJywgJ29uc2VsZWN0JyxcbiAgICAnb25zbG90Y2hhbmdlJywgJ29uc3RhbGxlZCcsICdvbnN0b3JhZ2UnLCAnb25zdWJtaXQnLCAnb25zdXNwZW5kJyxcbiAgICAnb250aW1ldXBkYXRlJywgJ29udG9nZ2xlJywgJ29udW5oYW5kbGVkcmVqZWN0aW9uJywgJ29udW5sb2FkJyxcbiAgICAnb252b2x1bWVjaGFuZ2UnLCAnb253YWl0aW5nJywgJ29ud2hlZWwnXG4gIF0sXG4gIGRpc2FsbG93ZWRUYWdzTW9kZTogJ2Rpc2NhcmQnLFxuICBhbGxvd2VkQXR0cmlidXRlczoge1xuICAgIGE6IFsgJ2hyZWYnLCAnbmFtZScsICd0YXJnZXQnIF0sXG4gICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IGFsbG93IGltZyBpdHNlbGYgYnkgZGVmYXVsdCwgYnV0XG4gICAgLy8gdGhlc2UgYXR0cmlidXRlcyB3b3VsZCBtYWtlIHNlbnNlIGlmIHdlIGRpZC5cbiAgICBpbWc6IFsgJ3NyYycsICdzcmNzZXQnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCcsICdsb2FkaW5nJyBdXG4gIH0sXG4gIGFsbG93ZWRFbXB0eUF0dHJpYnV0ZXM6IFtcbiAgICAnYWx0J1xuICBdLFxuICAvLyBMb3RzIG9mIHRoZXNlIHdvbid0IGNvbWUgdXAgYnkgZGVmYXVsdCBiZWNhdXNlIHdlIGRvbid0IGFsbG93IHRoZW1cbiAgc2VsZkNsb3Npbmc6IFsgJ2ltZycsICdicicsICdocicsICdhcmVhJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnaW5wdXQnLCAnbGluaycsICdtZXRhJyBdLFxuICAvLyBVUkwgc2NoZW1lcyB3ZSBwZXJtaXRcbiAgYWxsb3dlZFNjaGVtZXM6IFsgJ2h0dHAnLCAnaHR0cHMnLCAnZnRwJywgJ21haWx0bycsICd0ZWwnIF0sXG4gIGFsbG93ZWRTY2hlbWVzQnlUYWc6IHt9LFxuICBhbGxvd2VkU2NoZW1lc0FwcGxpZWRUb0F0dHJpYnV0ZXM6IFsgJ2hyZWYnLCAnc3JjJywgJ2NpdGUnIF0sXG4gIGFsbG93UHJvdG9jb2xSZWxhdGl2ZTogdHJ1ZSxcbiAgZW5mb3JjZUh0bWxCb3VuZGFyeTogZmFsc2UsXG4gIHBhcnNlU3R5bGVBdHRyaWJ1dGVzOiB0cnVlXG59O1xuXG5zYW5pdGl6ZUh0bWwuc2ltcGxlVHJhbnNmb3JtID0gZnVuY3Rpb24obmV3VGFnTmFtZSwgbmV3QXR0cmlicywgbWVyZ2UpIHtcbiAgbWVyZ2UgPSAobWVyZ2UgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogbWVyZ2U7XG4gIG5ld0F0dHJpYnMgPSBuZXdBdHRyaWJzIHx8IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0YWdOYW1lLCBhdHRyaWJzKSB7XG4gICAgbGV0IGF0dHJpYjtcbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGZvciAoYXR0cmliIGluIG5ld0F0dHJpYnMpIHtcbiAgICAgICAgYXR0cmlic1thdHRyaWJdID0gbmV3QXR0cmlic1thdHRyaWJdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJzID0gbmV3QXR0cmlicztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGFnTmFtZTogbmV3VGFnTmFtZSxcbiAgICAgIGF0dHJpYnM6IGF0dHJpYnNcbiAgICB9O1xuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJodG1scGFyc2VyIiwicmVxdWlyZSIsImVzY2FwZVN0cmluZ1JlZ2V4cCIsImlzUGxhaW5PYmplY3QiLCJkZWVwbWVyZ2UiLCJwYXJzZVNyY3NldCIsInBhcnNlIiwicG9zdGNzc1BhcnNlIiwibWVkaWFUYWdzIiwidnVsbmVyYWJsZVRhZ3MiLCJlYWNoIiwib2JqIiwiY2IiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImhhcyIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImZpbHRlciIsImEiLCJuIiwidiIsInB1c2giLCJpc0VtcHR5T2JqZWN0Iiwic3RyaW5naWZ5U3Jjc2V0IiwicGFyc2VkU3Jjc2V0IiwibWFwIiwicGFydCIsInVybCIsIkVycm9yIiwidyIsImgiLCJkIiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJzYW5pdGl6ZUh0bWwiLCJWQUxJRF9IVE1MX0FUVFJJQlVURV9OQU1FIiwiaHRtbCIsIm9wdGlvbnMiLCJfcmVjdXJzaW5nIiwidG9TdHJpbmciLCJyZXN1bHQiLCJ0ZW1wUmVzdWx0IiwiRnJhbWUiLCJ0YWciLCJhdHRyaWJzIiwidGhhdCIsInRhZ1Bvc2l0aW9uIiwibGVuZ3RoIiwidGV4dCIsIm1lZGlhQ2hpbGRyZW4iLCJ1cGRhdGVQYXJlbnROb2RlVGV4dCIsInN0YWNrIiwicGFyZW50RnJhbWUiLCJ1cGRhdGVQYXJlbnROb2RlTWVkaWFDaGlsZHJlbiIsImluY2x1ZGVzIiwiYXNzaWduIiwiZGVmYXVsdHMiLCJwYXJzZXIiLCJodG1sUGFyc2VyRGVmYXVsdHMiLCJ0YWdBbGxvd2VkIiwibmFtZSIsImFsbG93ZWRUYWdzIiwiaW5kZXhPZiIsImFsbG93VnVsbmVyYWJsZVRhZ3MiLCJjb25zb2xlIiwid2FybiIsIm5vblRleHRUYWdzQXJyYXkiLCJub25UZXh0VGFncyIsImFsbG93ZWRBdHRyaWJ1dGVzTWFwIiwiYWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwIiwiYWxsb3dlZEF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiZ2xvYlJlZ2V4IiwicmVwbGFjZSIsIlJlZ0V4cCIsImFsbG93ZWRDbGFzc2VzTWFwIiwiYWxsb3dlZENsYXNzZXNHbG9iTWFwIiwiYWxsb3dlZENsYXNzZXNSZWdleE1hcCIsImFsbG93ZWRDbGFzc2VzIiwiY2xhc3NlcyIsIkFycmF5IiwiaXNBcnJheSIsInRyYW5zZm9ybVRhZ3NNYXAiLCJ0cmFuc2Zvcm1UYWdzQWxsIiwidHJhbnNmb3JtVGFncyIsInRyYW5zZm9ybSIsInRyYW5zRnVuIiwic2ltcGxlVHJhbnNmb3JtIiwiZGVwdGgiLCJza2lwTWFwIiwidHJhbnNmb3JtTWFwIiwic2tpcFRleHQiLCJza2lwVGV4dERlcHRoIiwiYWRkZWRUZXh0IiwiaW5pdGlhbGl6ZVN0YXRlIiwiUGFyc2VyIiwib25vcGVudGFnIiwiZW5mb3JjZUh0bWxCb3VuZGFyeSIsImZyYW1lIiwic2tpcCIsImhhc1RleHQiLCJ0cmFuc2Zvcm1lZFRhZyIsInVuZGVmaW5lZCIsImlubmVyVGV4dCIsInRhZ05hbWUiLCJkaXNhbGxvd2VkVGFnc01vZGUiLCJuZXN0aW5nTGltaXQiLCJhbGxvd2VkU2NyaXB0SG9zdG5hbWVzIiwiYWxsb3dlZFNjcmlwdERvbWFpbnMiLCJ2YWx1ZSIsInRlc3QiLCJhbGxvd2VkRW1wdHlBdHRyaWJ1dGVzIiwibm9uQm9vbGVhbkF0dHJpYnV0ZXMiLCJwYXNzZWRBbGxvd2VkQXR0cmlidXRlc01hcENoZWNrIiwibyIsIm5ld1ZhbHVlIiwibXVsdGlwbGUiLCJzcGxpdFN0ckFycmF5Iiwic3BsaXQiLCJzIiwidmFsdWVzIiwiYWxsb3dlZFNjaGVtZXNBcHBsaWVkVG9BdHRyaWJ1dGVzIiwibmF1Z2h0eUhyZWYiLCJhbGxvd2VkIiwicGFyc2VkIiwicGFyc2VVcmwiLCJhbGxvd2VkSG9zdG5hbWUiLCJmaW5kIiwiaG9zdG5hbWUiLCJhbGxvd2VkRG9tYWluIiwiZG9tYWluIiwiZW5kc1dpdGgiLCJlIiwiaXNSZWxhdGl2ZVVybCIsImFsbG93SWZyYW1lUmVsYXRpdmVVcmxzIiwiYWxsb3dlZElmcmFtZUhvc3RuYW1lcyIsImFsbG93ZWRJZnJhbWVEb21haW5zIiwiZXZpbCIsImFsbG93ZWRTcGVjaWZpY0NsYXNzZXMiLCJhbGxvd2VkV2lsZGNhcmRDbGFzc2VzIiwiYWxsb3dlZFNwZWNpZmljQ2xhc3Nlc0dsb2IiLCJhbGxvd2VkU3BlY2lmaWNDbGFzc2VzUmVnZXgiLCJhbGxvd2VkV2lsZGNhcmRDbGFzc2VzR2xvYiIsImFsbG93ZWRDbGFzc2VzR2xvYnMiLCJjb25jYXQiLCJ0IiwiZmlsdGVyQ2xhc3NlcyIsInBhcnNlU3R5bGVBdHRyaWJ1dGVzIiwiYWJzdHJhY3RTeW50YXhUcmVlIiwiZmlsdGVyZWRBU1QiLCJmaWx0ZXJDc3MiLCJhbGxvd2VkU3R5bGVzIiwic3RyaW5naWZ5U3R5bGVBdHRyaWJ1dGVzIiwiZXNjYXBlSHRtbCIsInNlbGZDbG9zaW5nIiwidGV4dEZpbHRlciIsIm9udGV4dCIsImxhc3RGcmFtZSIsImVzY2FwZWQiLCJvbmNsb3NldGFnIiwiaXNJbXBsaWVkIiwicG9wIiwiZXhjbHVzaXZlRmlsdGVyIiwic3Vic3RyIiwid3JpdGUiLCJlbmQiLCJxdW90ZSIsImRlY29kZUVudGl0aWVzIiwiaHJlZiIsImZpcnN0SW5kZXgiLCJsYXN0SW5kZXgiLCJzdWJzdHJpbmciLCJtYXRjaGVzIiwibWF0Y2giLCJhbGxvd1Byb3RvY29sUmVsYXRpdmUiLCJzY2hlbWUiLCJ0b0xvd2VyQ2FzZSIsImFsbG93ZWRTY2hlbWVzQnlUYWciLCJhbGxvd2VkU2NoZW1lcyIsInN0YXJ0c1dpdGgiLCJiYXNlIiwiaSIsIlVSTCIsInByb3RvY29sIiwiYXN0UnVsZXMiLCJub2RlcyIsInNlbGVjdGVkUnVsZSIsInNlbGVjdG9yIiwicmVkdWNlIiwiZmlsdGVyRGVjbGFyYXRpb25zIiwiZXh0cmFjdGVkQXR0cmlidXRlcyIsImF0dHJPYmplY3QiLCJwcm9wIiwiaW1wb3J0YW50IiwiYWxsb3dlZERlY2xhcmF0aW9uc0xpc3QiLCJhdHRyaWJ1dGVPYmplY3QiLCJtYXRjaGVzUmVnZXgiLCJzb21lIiwicmVndWxhckV4cHJlc3Npb24iLCJhbGxvd2VkR2xvYnMiLCJjbHNzIiwiZ2xvYiIsImltZyIsIm5ld1RhZ05hbWUiLCJuZXdBdHRyaWJzIiwibWVyZ2UiLCJhdHRyaWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sanitize-html/index.js\n");

/***/ })

};
;